/**
 * Email Channel Routes
 * OAuth, Threads, Messages, and Drafts management
 */

import express from 'express';
import { PrismaClient } from '@prisma/client';
import { authenticateToken } from '../middleware/auth.js';
import { requireProOrAbove } from '../middleware/planGating.js';
import gmailService from '../services/gmail.js';
import outlookService from '../services/outlook.js';
import emailAggregator from '../services/email-aggregator.js';
import emailAI from '../services/email-ai.js';
import { handleEmailTurn } from '../core/email/index.js';
import { onEmailSent } from '../core/email/rag/indexingHooks.js';
import { buildEmailPairs, getPairStatistics } from '../services/email-pair-builder.js';

const router = express.Router();
const prisma = new PrismaClient();

// ==================== OAUTH ROUTES ====================

/**
 * Gmail OAuth - Get Auth URL
 * GET /api/email/gmail/auth
 */
router.get('/gmail/auth', authenticateToken, async (req, res) => {
  try {
    // Check if already connected to a different provider
    const existing = await prisma.emailIntegration.findUnique({
      where: { businessId: req.businessId }
    });

    if (existing && existing.connected && existing.provider !== 'GMAIL') {
      return res.status(400).json({
        error: 'Another email provider is already connected. Please disconnect it first.'
      });
    }

    const authUrl = gmailService.getAuthUrl(req.businessId);
    res.json({ authUrl });
  } catch (error) {
    console.error('Gmail auth error:', error);
    res.status(500).json({ error: 'Failed to generate Gmail auth URL' });
  }
});

/**
 * Gmail OAuth Callback
 * GET /api/email/gmail/callback
 */
router.get('/gmail/callback', async (req, res) => {
  try {
    const { code, state, error: oauthError } = req.query;

    if (oauthError) {
      console.error('Gmail OAuth error:', oauthError);
      return res.redirect(`${process.env.FRONTEND_URL}/dashboard/integrations?error=gmail-denied`);
    }

    if (!code || !state) {
      return res.redirect(`${process.env.FRONTEND_URL}/dashboard/integrations?error=gmail-invalid`);
    }

    const businessId = parseInt(state);

    await gmailService.handleCallback(code, businessId);

    console.log(`Gmail connected for business ${businessId}`);

    // Trigger style analysis in background
    import('../services/email-style-analyzer.js').then((module) => {
      module.analyzeWritingStyle(businessId).catch((err) => {
        console.error('Background style analysis failed:', err);
      });
    });

    res.redirect(`${process.env.FRONTEND_URL}/dashboard/integrations?success=gmail`);
  } catch (error) {
    console.error('Gmail callback error:', error);
    res.redirect(`${process.env.FRONTEND_URL}/dashboard/integrations?error=gmail-failed`);
  }
});

/**
 * Outlook OAuth - Get Auth URL
 * GET /api/email/outlook/auth
 */
router.get('/outlook/auth', authenticateToken, async (req, res) => {
  try {
    // Check if already connected to a different provider
    const existing = await prisma.emailIntegration.findUnique({
      where: { businessId: req.businessId }
    });

    if (existing && existing.connected && existing.provider !== 'OUTLOOK') {
      return res.status(400).json({
        error: 'Another email provider is already connected. Please disconnect it first.'
      });
    }

    const authUrl = outlookService.getAuthUrl(req.businessId);
    res.json({ authUrl });
  } catch (error) {
    console.error('Outlook auth error:', error);
    res.status(500).json({ error: 'Failed to generate Outlook auth URL' });
  }
});

/**
 * Outlook OAuth Callback
 * GET /api/email/outlook/callback
 */
router.get('/outlook/callback', async (req, res) => {
  try {
    const { code, state, error: oauthError } = req.query;

    if (oauthError) {
      console.error('Outlook OAuth error:', oauthError);
      return res.redirect(`${process.env.FRONTEND_URL}/dashboard/integrations?error=outlook-denied`);
    }

    if (!code || !state) {
      return res.redirect(`${process.env.FRONTEND_URL}/dashboard/integrations?error=outlook-invalid`);
    }

    const businessId = parseInt(state);

    await outlookService.handleCallback(code, businessId);

    console.log(`Outlook connected for business ${businessId}`);

    // Trigger style analysis in background
    import('../services/email-style-analyzer.js').then((module) => {
      module.analyzeWritingStyle(businessId).catch((err) => {
        console.error('Background style analysis failed:', err);
      });
    });

    res.redirect(`${process.env.FRONTEND_URL}/dashboard/integrations?success=outlook`);
  } catch (error) {
    console.error('Outlook callback error:', error);
    res.redirect(`${process.env.FRONTEND_URL}/dashboard/integrations?error=outlook-failed`);
  }
});

/**
 * Disconnect Email
 * POST /api/email/disconnect
 */
router.post('/disconnect', authenticateToken, async (req, res) => {
  try {
    await emailAggregator.disconnect(req.businessId);
    res.json({ success: true, message: 'Email disconnected successfully' });
  } catch (error) {
    console.error('Disconnect error:', error);
    res.status(500).json({ error: 'Failed to disconnect email' });
  }
});

/**
 * Get Email Connection Status
 * GET /api/email/status
 */
router.get('/status', authenticateToken, async (req, res) => {
  try {
    const status = await emailAggregator.getStatus(req.businessId);
    res.json(status);
  } catch (error) {
    console.error('Status error:', error);
    res.status(500).json({ error: 'Failed to get email status' });
  }
});

// ==================== THREAD ROUTES ====================

/**
 * Get Thread List
 * GET /api/email/threads
 * P1: PRO+ gating for email usage
 */
router.get('/threads', authenticateToken, requireProOrAbove, async (req, res) => {
  try {
    const { status, limit = 20, offset = 0 } = req.query;

    const { threads, total } = await emailAggregator.getThreadsFromDb(
      req.businessId,
      {
        status,
        limit: parseInt(limit),
        offset: parseInt(offset)
      }
    );

    res.json({
      threads,
      total,
      limit: parseInt(limit),
      offset: parseInt(offset)
    });
  } catch (error) {
    console.error('Get threads error:', error);
    res.status(500).json({ error: 'Failed to get threads' });
  }
});

/**
 * Get Single Thread
 * GET /api/email/threads/:threadId
 */
router.get('/threads/:threadId', authenticateToken, async (req, res) => {
  try {
    const thread = await emailAggregator.getThreadFromDb(
      req.businessId,
      req.params.threadId
    );

    if (!thread) {
      return res.status(404).json({ error: 'Thread not found' });
    }

    res.json(thread);
  } catch (error) {
    console.error('Get thread error:', error);
    res.status(500).json({ error: 'Failed to get thread' });
  }
});

/**
 * Close Thread
 * POST /api/email/threads/:threadId/close
 */
router.post('/threads/:threadId/close', authenticateToken, async (req, res) => {
  try {
    const thread = await prisma.emailThread.findFirst({
      where: {
        id: req.params.threadId,
        businessId: req.businessId
      }
    });

    if (!thread) {
      return res.status(404).json({ error: 'Thread not found' });
    }

    await emailAggregator.updateThreadStatus(thread.id, 'CLOSED');

    res.json({ success: true, message: 'Thread closed' });
  } catch (error) {
    console.error('Close thread error:', error);
    res.status(500).json({ error: 'Failed to close thread' });
  }
});

/**
 * Update Thread Status (Manual Tagging)
 * PATCH /api/email/threads/:threadId
 * Allows user to manually set thread status (e.g., NO_REPLY_NEEDED)
 */
router.patch('/threads/:threadId', authenticateToken, async (req, res) => {
  try {
    const { status } = req.body;
    const validStatuses = ['PENDING_REPLY', 'NO_REPLY_NEEDED', 'CLOSED'];

    if (!status || !validStatuses.includes(status)) {
      return res.status(400).json({
        error: `Invalid status. Must be one of: ${validStatuses.join(', ')}`
      });
    }

    const thread = await prisma.emailThread.findFirst({
      where: {
        id: req.params.threadId,
        businessId: req.businessId
      }
    });

    if (!thread) {
      return res.status(404).json({ error: 'Thread not found' });
    }

    await emailAggregator.updateThreadStatus(thread.id, status);

    res.json({ success: true, message: `Thread status updated to ${status}` });
  } catch (error) {
    console.error('Update thread status error:', error);
    res.status(500).json({ error: 'Failed to update thread status' });
  }
});

// ==================== DRAFT ROUTES ====================

/**
 * Get Pending Drafts
 * GET /api/email/drafts
 */
router.get('/drafts', authenticateToken, async (req, res) => {
  try {
    const drafts = await emailAI.getPendingDrafts(req.businessId);
    res.json({ drafts });
  } catch (error) {
    console.error('Get drafts error:', error);
    res.status(500).json({ error: 'Failed to get drafts' });
  }
});

/**
 * Get Single Draft
 * GET /api/email/drafts/:draftId
 */
router.get('/drafts/:draftId', authenticateToken, async (req, res) => {
  try {
    const draft = await emailAI.getDraft(req.params.draftId);

    if (!draft || draft.businessId !== req.businessId) {
      return res.status(404).json({ error: 'Draft not found' });
    }

    res.json(draft);
  } catch (error) {
    console.error('Get draft error:', error);
    res.status(500).json({ error: 'Failed to get draft' });
  }
});

/**
 * Update Draft Content
 * PUT /api/email/drafts/:draftId
 */
router.put('/drafts/:draftId', authenticateToken, async (req, res) => {
  try {
    const { content } = req.body;

    const draft = await emailAI.getDraft(req.params.draftId);

    if (!draft || draft.businessId !== req.businessId) {
      return res.status(404).json({ error: 'Draft not found' });
    }

    const updated = await emailAI.updateDraft(req.params.draftId, content);
    res.json(updated);
  } catch (error) {
    console.error('Update draft error:', error);
    res.status(500).json({ error: 'Failed to update draft' });
  }
});

/**
 * Approve Draft
 * POST /api/email/drafts/:draftId/approve
 */
router.post('/drafts/:draftId/approve', authenticateToken, async (req, res) => {
  try {
    const draft = await emailAI.getDraft(req.params.draftId);

    if (!draft || draft.businessId !== req.businessId) {
      return res.status(404).json({ error: 'Draft not found' });
    }

    const approved = await emailAI.approveDraft(req.params.draftId, req.userId);
    res.json(approved);
  } catch (error) {
    console.error('Approve draft error:', error);
    res.status(500).json({ error: 'Failed to approve draft' });
  }
});

/**
 * Convert plain text to HTML with proper formatting
 * @param {string} text - Plain text content
 * @returns {string} - HTML formatted content
 */
function textToHtml(text) {
  if (!text) return '';
  // Escape HTML entities
  let html = text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');

  // Convert newlines to <br> tags
  html = html.replace(/\n/g, '<br>');

  return html;
}

/**
 * Build HTML email with styling and signature
 * @param {string} bodyContent - The email body content (plain text)
 * @param {object} business - Business object with name
 * @param {string} senderEmail - Sender's email address
 * @returns {string} - Full HTML email
 */
function buildHtmlEmail(bodyContent, business, senderEmail) {
  const htmlBody = textToHtml(bodyContent);
  const businessName = business?.name || '';

  return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0; }
    .email-body { padding: 0; }
    .signature { margin-top: 24px; padding-top: 16px; border-top: 1px solid #e5e7eb; color: #6b7280; font-size: 14px; }
    .signature-name { font-weight: 600; color: #333; }
  </style>
</head>
<body>
  <div class="email-body">
    ${htmlBody}
  </div>
  <div class="signature">
    <p class="signature-name">${businessName}</p>
    <p>${senderEmail}</p>
  </div>
</body>
</html>`.trim();
}

/**
 * Send Draft
 * POST /api/email/drafts/:draftId/send
 */
router.post('/drafts/:draftId/send', authenticateToken, async (req, res) => {
  try {
    const draft = await emailAI.getDraft(req.params.draftId);

    if (!draft || draft.businessId !== req.businessId) {
      return res.status(404).json({ error: 'Draft not found' });
    }

    const thread = draft.thread;
    const plainContent = draft.editedContent || draft.generatedContent;

    // Get the email integration to find connected email
    const integration = await emailAggregator.getIntegration(req.businessId);

    // Get business for signature
    const business = await prisma.business.findUnique({
      where: { id: req.businessId }
    });

    // Convert plain text to HTML with signature
    const htmlContent = buildHtmlEmail(plainContent, business, integration.email);

    // Build reply options
    const options = {
      threadId: thread.threadId,
      conversationId: thread.threadId // For Outlook
    };

    // If replying to a specific message, include reference
    if (draft.message) {
      options.inReplyTo = draft.message.messageId;
      options.replyToId = draft.message.messageId;
    }

    // Send the email (with HTML content)
    const result = await emailAggregator.sendMessage(
      req.businessId,
      thread.customerEmail,
      `Re: ${thread.subject}`,
      htmlContent,
      options
    );

    // Save the sent message to database
    await prisma.emailMessage.upsert({
      where: {
        threadId_messageId: {
          threadId: thread.id,
          messageId: result.messageId || `sent-${Date.now()}-${Math.random().toString(36).substring(7)}`
        }
      },
      update: {
        status: 'SENT',
        sentAt: new Date()
      },
      create: {
        threadId: thread.id,
        messageId: result.messageId || `sent-${Date.now()}-${Math.random().toString(36).substring(7)}`,
        direction: 'OUTBOUND',
        fromEmail: integration.email,
        fromName: business?.name || null,
        toEmail: thread.customerEmail,
        subject: `Re: ${thread.subject}`,
        bodyText: plainContent,
        bodyHtml: htmlContent,
        status: 'SENT',
        sentAt: new Date()
      }
    });

    // Update draft status to SENT
    await prisma.emailDraft.update({
      where: { id: draft.id },
      data: {
        status: 'SENT',
        sentAt: new Date()
      }
    });

    // Update thread status to REPLIED
    await prisma.emailThread.update({
      where: { id: thread.id },
      data: { status: 'REPLIED' }
    });

    // Index sent email for RAG (async, non-blocking)
    onEmailSent({
      messageId: result.messageId,
      threadId: thread.id,
      businessId: req.businessId,
      classification: draft.classification // If stored
    }).catch(err => {
      console.error('RAG indexing failed (non-blocking):', err);
    });

    res.json({
      success: true,
      message: 'Email sent successfully',
      messageId: result.messageId
    });
  } catch (error) {
    console.error('Send draft error:', error);
    res.status(500).json({ error: 'Failed to send email' });
  }
});

/**
 * Reject Draft
 * POST /api/email/drafts/:draftId/reject
 */
router.post('/drafts/:draftId/reject', authenticateToken, async (req, res) => {
  try {
    const draft = await emailAI.getDraft(req.params.draftId);

    if (!draft || draft.businessId !== req.businessId) {
      return res.status(404).json({ error: 'Draft not found' });
    }

    const rejected = await emailAI.rejectDraft(req.params.draftId, req.userId);
    res.json(rejected);
  } catch (error) {
    console.error('Reject draft error:', error);
    res.status(500).json({ error: 'Failed to reject draft' });
  }
});

/**
 * Generate Draft Manually for a Thread (NEW ORCHESTRATOR)
 * POST /api/email/threads/:threadId/generate-draft
 *
 * Uses the new email orchestrator pipeline with:
 * - Classification
 * - Tool gating (read-only)
 * - Guardrails (recipient, action-claim, verification)
 * - Provider draft creation
 */
router.post('/threads/:threadId/generate-draft', authenticateToken, async (req, res) => {
  try {
    const { threadId } = req.params;
    const { messageId, createProviderDraft = true } = req.body;

    // Validate thread exists and belongs to business
    const thread = await prisma.emailThread.findFirst({
      where: {
        id: threadId,
        businessId: req.businessId
      }
    });

    if (!thread) {
      return res.status(404).json({ error: 'Thread not found' });
    }

    // Check if draft already exists for the latest inbound message
    const latestInbound = await prisma.emailMessage.findFirst({
      where: {
        threadId: thread.id,
        direction: 'INBOUND'
      },
      orderBy: { createdAt: 'desc' }
    });

    if (!latestInbound) {
      return res.status(400).json({ error: 'No inbound message found in this thread' });
    }

    const targetMessageId = messageId || latestInbound.id;

    // Check for existing pending draft
    const existingDraft = await prisma.emailDraft.findFirst({
      where: {
        messageId: targetMessageId,
        status: 'PENDING_REVIEW'
      }
    });

    if (existingDraft) {
      return res.status(400).json({
        error: 'A pending draft already exists for this message',
        draftId: existingDraft.id
      });
    }

    // Use new orchestrator
    const result = await handleEmailTurn({
      businessId: req.businessId,
      threadId,
      messageId: targetMessageId,
      options: {
        createProviderDraft
      }
    });

    if (!result.success) {
      // Handle specific error codes
      if (result.errorCode === 'GUARDRAIL_BLOCKED') {
        return res.status(400).json({
          error: result.error,
          errorCode: result.errorCode,
          blockedBy: result.blockedBy
        });
      }

      return res.status(500).json({
        error: result.error || 'Failed to generate draft',
        errorCode: result.errorCode
      });
    }

    res.json({
      success: true,
      message: 'Draft generated successfully',
      draft: result.draft,
      classification: result.classification,
      toolsCalled: result.toolsCalled,
      guardrailsApplied: result.guardrailsApplied,
      providerDraftId: result.providerDraftId,
      metrics: {
        totalDuration: result.metrics?.totalDuration,
        steps: result.metrics?.steps
      }
    });
  } catch (error) {
    console.error('Manual draft generation error:', error);
    res.status(500).json({ error: 'Failed to generate draft' });
  }
});

/**
 * Generate Draft using LEGACY method (fallback)
 * POST /api/email/threads/:threadId/generate-draft-legacy
 *
 * Kept for backward compatibility if needed
 */
router.post('/threads/:threadId/generate-draft-legacy', authenticateToken, async (req, res) => {
  try {
    const { threadId } = req.params;

    const thread = await prisma.emailThread.findFirst({
      where: {
        id: threadId,
        businessId: req.businessId
      }
    });

    if (!thread) {
      return res.status(404).json({ error: 'Thread not found' });
    }

    const latestInbound = await prisma.emailMessage.findFirst({
      where: {
        threadId: thread.id,
        direction: 'INBOUND'
      },
      orderBy: { createdAt: 'desc' }
    });

    if (!latestInbound) {
      return res.status(400).json({ error: 'No inbound message found in this thread' });
    }

    const existingDraft = await prisma.emailDraft.findFirst({
      where: {
        messageId: latestInbound.id,
        status: 'PENDING_REVIEW'
      }
    });

    if (existingDraft) {
      return res.status(400).json({
        error: 'A pending draft already exists for this message',
        draftId: existingDraft.id
      });
    }

    // Use legacy emailAI service
    const draft = await emailAI.generateDraft(req.businessId, thread, latestInbound);

    await prisma.emailThread.update({
      where: { id: thread.id },
      data: { status: 'DRAFT_READY' }
    });

    res.json({
      success: true,
      message: 'Draft generated successfully (legacy)',
      draft
    });
  } catch (error) {
    console.error('Legacy draft generation error:', error);
    res.status(500).json({ error: 'Failed to generate draft' });
  }
});

/**
 * Regenerate Draft
 * POST /api/email/drafts/:draftId/regenerate
 */
router.post('/drafts/:draftId/regenerate', authenticateToken, async (req, res) => {
  try {
    const { feedback } = req.body;

    const draft = await emailAI.getDraft(req.params.draftId);

    if (!draft || draft.businessId !== req.businessId) {
      return res.status(404).json({ error: 'Draft not found' });
    }

    const regenerated = await emailAI.regenerateDraft(req.params.draftId, feedback);
    res.json(regenerated);
  } catch (error) {
    console.error('Regenerate draft error:', error);
    res.status(500).json({ error: 'Failed to regenerate draft' });
  }
});

// ==================== SYNC ROUTES ====================

/**
 * Manual Sync (Legacy - returns after completion)
 * POST /api/email/sync
 *
 * NOTE: This route ONLY syncs emails - NO automatic draft generation.
 * Draft generation is 100% manual via the generate-draft endpoint.
 */
router.post('/sync', authenticateToken, async (req, res) => {
  try {
    const status = await emailAggregator.getStatus(req.businessId);

    if (!status.connected) {
      return res.status(400).json({ error: 'No email provider connected' });
    }

    // Get new messages from provider
    const newMessages = await emailAggregator.syncNewMessages(req.businessId);

    // Get connected email to determine direction
    const integration = await emailAggregator.getIntegration(req.businessId);
    const connectedEmail = integration.email;

    let processedCount = 0;

    for (const message of newMessages) {
      // Determine direction
      const direction = message.from.email.toLowerCase() === connectedEmail.toLowerCase()
        ? 'OUTBOUND'
        : 'INBOUND';

      // Save to database
      const { thread, isNew } = await emailAggregator.saveMessageToDb(
        req.businessId,
        message,
        direction
      );

      if (isNew) {
        processedCount++;

        // For OUTBOUND messages (sent by user via external app), mark thread as REPLIED
        if (direction === 'OUTBOUND' && thread.status !== 'REPLIED') {
          await prisma.emailThread.update({
            where: { id: thread.id },
            data: { status: 'REPLIED' }
          });
          console.log(`[Email Sync] Thread ${thread.id} marked as REPLIED (outbound message detected)`);
        }

        // For INBOUND messages: If thread was REPLIED or CLOSED, reopen it as PENDING_REPLY
        // This handles the case where a customer sends a follow-up email after we replied
        if (direction === 'INBOUND' && (thread.status === 'REPLIED' || thread.status === 'CLOSED' || thread.status === 'NO_REPLY_NEEDED')) {
          // Cancel any pending drafts for this thread (they're for old messages)
          await prisma.emailDraft.updateMany({
            where: {
              threadId: thread.id,
              status: 'PENDING_REVIEW'
            },
            data: { status: 'CANCELLED' }
          });

          await prisma.emailThread.update({
            where: { id: thread.id },
            data: { status: 'PENDING_REPLY' }
          });
          console.log(`[Email Sync] Thread ${thread.id} reopened as PENDING_REPLY (new inbound message after reply)`);
        }
      }
    }

    res.json({
      success: true,
      message: `Synced ${processedCount} new messages`,
      processedCount
    });
  } catch (error) {
    console.error('Sync error:', error);
    res.status(500).json({ error: 'Failed to sync messages' });
  }
});

/**
 * Real-time Sync with Server-Sent Events (SSE)
 * GET /api/email/sync/stream
 *
 * Streams sync progress events to frontend:
 * - 'started': Sync initiated
 * - 'thread': New thread processed (includes thread data)
 * - 'completed': Sync finished
 * - 'error': Error occurred
 */
router.get('/sync/stream', authenticateToken, async (req, res) => {
  // Set SSE headers
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');
  res.flushHeaders();

  const sendEvent = (event, data) => {
    res.write(`event: ${event}\n`);
    res.write(`data: ${JSON.stringify(data)}\n\n`);
  };

  try {
    const status = await emailAggregator.getStatus(req.businessId);

    if (!status.connected) {
      sendEvent('error', { error: 'No email provider connected' });
      return res.end();
    }

    sendEvent('started', { message: 'Starting email sync...' });

    // Get new messages from provider
    const newMessages = await emailAggregator.syncNewMessages(req.businessId);

    // Get connected email to determine direction
    const integration = await emailAggregator.getIntegration(req.businessId);
    const connectedEmail = integration.email;

    let processedCount = 0;

    for (const message of newMessages) {
      // Determine direction
      const direction = message.from.email.toLowerCase() === connectedEmail.toLowerCase()
        ? 'OUTBOUND'
        : 'INBOUND';

      // Save to database
      const { thread, isNew } = await emailAggregator.saveMessageToDb(
        req.businessId,
        message,
        direction
      );

      if (isNew) {
        processedCount++;

        // For OUTBOUND messages (sent by user via external app), mark thread as REPLIED
        if (direction === 'OUTBOUND' && thread.status !== 'REPLIED') {
          await prisma.emailThread.update({
            where: { id: thread.id },
            data: { status: 'REPLIED' }
          });
        }

        // For INBOUND messages: If thread was REPLIED or CLOSED, reopen it as PENDING_REPLY
        if (direction === 'INBOUND' && (thread.status === 'REPLIED' || thread.status === 'CLOSED' || thread.status === 'NO_REPLY_NEEDED')) {
          // Cancel any pending drafts for this thread (they're for old messages)
          await prisma.emailDraft.updateMany({
            where: {
              threadId: thread.id,
              status: 'PENDING_REVIEW'
            },
            data: { status: 'CANCELLED' }
          });

          await prisma.emailThread.update({
            where: { id: thread.id },
            data: { status: 'PENDING_REPLY' }
          });
        }

        // Send thread update event to frontend
        // Fetch full thread data with messages and drafts
        const fullThread = await prisma.emailThread.findUnique({
          where: { id: thread.id },
          include: {
            messages: {
              orderBy: { createdAt: 'asc' },
              take: 5
            },
            drafts: {
              where: { status: 'PENDING_REVIEW' },
              orderBy: { createdAt: 'desc' },
              take: 1
            }
          }
        });

        sendEvent('thread', {
          thread: fullThread,
          isNew: true,
          direction,
          processedCount
        });
      }
    }

    // Send completion event
    sendEvent('completed', {
      message: `Synced ${processedCount} new messages`,
      processedCount,
      totalMessages: newMessages.length
    });

    res.end();
  } catch (error) {
    console.error('Sync stream error:', error);
    sendEvent('error', { error: 'Failed to sync messages', message: error.message });
    res.end();
  }
});

// ==================== STATS ROUTES ====================

/**
 * Get Email Stats
 * GET /api/email/stats
 */
router.get('/stats', authenticateToken, async (req, res) => {
  try {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const [
      newCount,
      pendingCount,
      draftReadyCount,
      repliedCount,
      repliedTodayCount,
      noReplyNeededCount,
      totalThreads
    ] = await Promise.all([
      // NEW status (new emails without any action)
      prisma.emailThread.count({
        where: {
          businessId: req.businessId,
          status: 'NEW'
        }
      }),
      // PENDING_REPLY (legacy - kept for backward compatibility)
      prisma.emailThread.count({
        where: {
          businessId: req.businessId,
          status: 'PENDING_REPLY'
        }
      }),
      // DRAFT_READY (AI draft generated)
      prisma.emailThread.count({
        where: {
          businessId: req.businessId,
          status: 'DRAFT_READY'
        }
      }),
      // Total REPLIED count
      prisma.emailThread.count({
        where: {
          businessId: req.businessId,
          status: 'REPLIED'
        }
      }),
      // Replied today count
      prisma.emailThread.count({
        where: {
          businessId: req.businessId,
          status: 'REPLIED',
          updatedAt: { gte: today }
        }
      }),
      // NO_REPLY_NEEDED
      prisma.emailThread.count({
        where: {
          businessId: req.businessId,
          status: 'NO_REPLY_NEEDED'
        }
      }),
      // Total threads
      prisma.emailThread.count({
        where: { businessId: req.businessId }
      })
    ]);

    res.json({
      newCount,
      pendingCount,
      draftReadyCount,
      repliedCount,
      repliedTodayCount,
      noReplyNeededCount,
      totalThreads
    });
  } catch (error) {
    console.error('Stats error:', error);
    res.status(500).json({ error: 'Failed to get stats' });
  }
});

// ==================== WEBHOOK ROUTES ====================

/**
 * Gmail Push Notification Webhook
 * POST /api/email/webhook/gmail
 */
router.post('/webhook/gmail', async (req, res) => {
  try {
    // Gmail sends base64 encoded data
    const message = req.body.message;
    if (message && message.data) {
      const data = JSON.parse(Buffer.from(message.data, 'base64').toString());
      console.log('Gmail webhook received:', data);
      // TODO: Process the notification and sync new messages
    }
    res.status(200).send('OK');
  } catch (error) {
    console.error('Gmail webhook error:', error);
    res.status(200).send('OK'); // Always return 200 to prevent retries
  }
});

/**
 * Outlook Subscription Webhook
 * POST /api/email/webhook/outlook
 */
router.post('/webhook/outlook', async (req, res) => {
  try {
    // Validation request
    if (req.query.validationToken) {
      return res.status(200).send(req.query.validationToken);
    }

    // Notification
    const notifications = req.body.value || [];
    console.log('Outlook webhook received:', notifications);
    // TODO: Process the notifications and sync new messages

    res.status(202).send('Accepted');
  } catch (error) {
    console.error('Outlook webhook error:', error);
    res.status(202).send('Accepted');
  }
});

// ==================== STYLE LEARNING ROUTES ====================

import { analyzeWritingStyle, getStyleProfile, reanalyzeWritingStyle } from '../services/email-style-analyzer.js';
import { classifyEmailSender, overrideClassification, getClassificationStats } from '../services/email-classifier.js';

/**
 * Get Style Profile
 * GET /api/email/style-profile
 */
router.get('/style-profile', authenticateToken, async (req, res) => {
  try {
    const profile = await getStyleProfile(req.businessId);

    if (!profile) {
      return res.status(404).json({ error: 'No email integration found' });
    }

    res.json({
      styleProfile: profile.styleProfile,
      status: profile.styleAnalysisStatus,
      analyzedAt: profile.styleAnalyzedAt,
    });
  } catch (error) {
    console.error('Get style profile error:', error);
    res.status(500).json({ error: 'Failed to get style profile' });
  }
});

/**
 * Trigger Style Analysis
 * POST /api/email/style-profile/analyze
 */
router.post('/style-profile/analyze', authenticateToken, async (req, res) => {
  try {
    // Check if integration exists
    const integration = await prisma.emailIntegration.findUnique({
      where: { businessId: req.businessId },
    });

    if (!integration || !integration.connected) {
      return res.status(400).json({ error: 'No email provider connected' });
    }

    // If already processing, don't start another
    if (integration.styleAnalysisStatus === 'PROCESSING') {
      return res.status(400).json({ error: 'Analysis is already in progress' });
    }

    // Start analysis in background
    const result = await reanalyzeWritingStyle(req.businessId);

    res.json({
      success: true,
      message: 'Style analysis started',
      status: 'PROCESSING',
    });
  } catch (error) {
    console.error('Trigger style analysis error:', error);
    res.status(500).json({ error: 'Failed to start style analysis' });
  }
});

// ==================== SMART FILTERING ROUTES ====================

/**
 * Classify Email Sender
 * POST /api/email/classify
 */
router.post('/classify', authenticateToken, async (req, res) => {
  try {
    const { senderEmail, subject, snippet, headers } = req.body;

    if (!senderEmail) {
      return res.status(400).json({ error: 'Sender email is required' });
    }

    const result = await classifyEmailSender(req.businessId, senderEmail, {
      subject,
      snippet,
      headers,
    });

    res.json(result);
  } catch (error) {
    console.error('Classify email error:', error);
    res.status(500).json({ error: 'Failed to classify email' });
  }
});

/**
 * Override Classification
 * POST /api/email/classify/override
 */
router.post('/classify/override', authenticateToken, async (req, res) => {
  try {
    const { senderEmail, classification } = req.body;

    if (!senderEmail || !classification) {
      return res.status(400).json({ error: 'Sender email and classification are required' });
    }

    if (!['PERSONAL', 'AUTOMATED'].includes(classification)) {
      return res.status(400).json({ error: 'Invalid classification. Must be PERSONAL or AUTOMATED' });
    }

    const result = await overrideClassification(req.businessId, senderEmail, classification);

    res.json({
      success: true,
      message: 'Classification updated',
      result,
    });
  } catch (error) {
    console.error('Override classification error:', error);
    res.status(500).json({ error: 'Failed to override classification' });
  }
});

/**
 * Get Classification Stats
 * GET /api/email/classify/stats
 */
router.get('/classify/stats', authenticateToken, async (req, res) => {
  try {
    const stats = await getClassificationStats(req.businessId);

    const summary = {
      total: 0,
      personal: 0,
      automated: 0,
      bySource: {
        heuristic: 0,
        ai: 0,
        userOverride: 0,
      },
    };

    for (const stat of stats) {
      summary.total += stat._count;
      if (stat.classification === 'PERSONAL') {
        summary.personal += stat._count;
      } else {
        summary.automated += stat._count;
      }
      if (stat.classifiedBy === 'HEURISTIC') {
        summary.bySource.heuristic += stat._count;
      } else if (stat.classifiedBy === 'AI') {
        summary.bySource.ai += stat._count;
      } else {
        summary.bySource.userOverride += stat._count;
      }
    }

    res.json(summary);
  } catch (error) {
    console.error('Get classification stats error:', error);
    res.status(500).json({ error: 'Failed to get classification stats' });
  }
});

// ==================== SIGNATURE ROUTES ====================

/**
 * Get email signature settings
 * GET /api/email/signature
 */
router.get('/signature', authenticateToken, async (req, res) => {
  try {
    const integration = await prisma.emailIntegration.findUnique({
      where: { businessId: req.businessId },
      select: {
        emailSignature: true,
        signatureType: true
      }
    });

    if (!integration) {
      return res.json({
        emailSignature: null,
        signatureType: 'PLAIN'
      });
    }

    res.json({
      emailSignature: integration.emailSignature,
      signatureType: integration.signatureType
    });
  } catch (error) {
    console.error('Get signature error:', error);
    res.status(500).json({ error: 'Failed to get email signature' });
  }
});

/**
 * Update email signature
 * PUT /api/email/signature
 */
router.put('/signature', authenticateToken, async (req, res) => {
  try {
    const { emailSignature, signatureType } = req.body;

    // Validate signatureType
    if (signatureType && !['PLAIN', 'HTML'].includes(signatureType)) {
      return res.status(400).json({ error: 'signatureType must be PLAIN or HTML' });
    }

    // Check if email integration exists
    const existing = await prisma.emailIntegration.findUnique({
      where: { businessId: req.businessId }
    });

    if (!existing) {
      return res.status(404).json({
        error: 'Email integration not found. Please connect your email first.'
      });
    }

    // Update signature
    const updated = await prisma.emailIntegration.update({
      where: { businessId: req.businessId },
      data: {
        emailSignature: emailSignature || null,
        signatureType: signatureType || 'PLAIN'
      },
      select: {
        emailSignature: true,
        signatureType: true
      }
    });

    res.json({
      success: true,
      emailSignature: updated.emailSignature,
      signatureType: updated.signatureType,
      message: 'Email signature updated successfully'
    });
  } catch (error) {
    console.error('Update signature error:', error);
    res.status(500).json({ error: 'Failed to update email signature' });
  }
});

// ==================== EMAIL PAIR ROUTES (Learning Dataset) ====================

/**
 * Build email pairs from sent emails
 * POST /api/email/pairs/build
 * Body: { daysBack: 30, limit: 100 }
 */
router.post('/pairs/build', authenticateToken, async (req, res) => {
  try {
    const { daysBack = 30, limit = 100 } = req.body;

    console.log(`[EmailPairs] Building pairs for business ${req.businessId}`);

    const result = await buildEmailPairs(req.businessId, { daysBack, limit });

    res.json(result);
  } catch (error) {
    console.error('Build pairs error:', error);
    res.status(500).json({ error: 'Failed to build email pairs' });
  }
});

/**
 * Get pair statistics
 * GET /api/email/pairs/stats
 */
router.get('/pairs/stats', authenticateToken, async (req, res) => {
  try {
    const stats = await getPairStatistics(req.businessId);
    res.json(stats);
  } catch (error) {
    console.error('Get pair stats error:', error);
    res.status(500).json({ error: 'Failed to get pair statistics' });
  }
});

export default router;
