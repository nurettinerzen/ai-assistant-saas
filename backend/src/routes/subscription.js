// ============================================================================
// UPDATED SUBSCRIPTION ROUTES
// ============================================================================
// FILE: backend/src/routes/subscription.js
//
// Enhanced with iyzico support for Turkish customers
// Stripe for global customers, iyzico for Turkey (TR)
// ============================================================================

// Load environment variables first
import dotenv from 'dotenv';
dotenv.config();

import express from 'express';
import { PrismaClient } from '@prisma/client';
import { authenticateToken, verifyBusinessAccess } from '../middleware/auth.js';
import Stripe from 'stripe';
import crypto from 'crypto';
import emailService from '../services/emailService.js';
import iyzicoSubscription from '../services/iyzicoSubscription.js';
import paymentProvider from '../services/paymentProvider.js';
import { getEffectivePlanConfig } from '../services/planConfig.js';
import { isPhoneInboundEnabledForBusinessRecord } from '../services/phoneInboundGate.js';
import { buildPhoneEntitlements } from '../services/phonePlanEntitlements.js';

const router = express.Router();
const prisma = new PrismaClient();

// Lazy initialize Stripe to ensure env vars are loaded
let stripe = null;
function getStripe() {
  if (!stripe && process.env.STRIPE_SECRET_KEY) {
    stripe = new Stripe(process.env.STRIPE_SECRET_KEY);
  }
  return stripe;
}

function hashValue(value) {
  if (!value) return null;
  return crypto.createHash('sha256').update(String(value), 'utf8').digest('hex').slice(0, 12);
}

// Plan configurations with both Stripe and iyzico pricing
// Updated: January 2026 - synced with pricing.js
const PLAN_CONFIG = {
  FREE: {
    name: 'FREE',
    price: 0,
    priceTRY: 0,
    minutesLimit: 0,
    callsLimit: 0,
    assistantsLimit: 1,
    phoneNumbersLimit: 0
  },
  PAYG: {
    name: 'PAYG',
    price: 0,
    priceTRY: 0,
    minutesLimit: 0, // Pay per minute, no limit
    callsLimit: -1, // unlimited
    assistantsLimit: 1,
    phoneNumbersLimit: 1,
    isPrepaid: true // Balance-based, not subscription
  },
  STARTER: {
    name: 'STARTER',
    stripePriceId: process.env.STRIPE_STARTER_PRICE_ID || 'price_starter',
    iyzicoPlanRef: process.env.IYZICO_STARTER_PLAN_REF,
    price: 55,        // $55 USD
    priceTRY: 2499,   // â‚º2,499 TRY
    minutesLimit: 150,
    callsLimit: -1,   // unlimited
    assistantsLimit: 3,
    phoneNumbersLimit: -1 // unlimited
  },
  PRO: {
    name: 'PRO',
    stripePriceId: process.env.STRIPE_PRO_PRICE_ID || 'price_pro',
    iyzicoPlanRef: process.env.IYZICO_PRO_PLAN_REF,
    price: 167,       // $167 USD
    priceTRY: 7499,   // â‚º7,499 TRY
    minutesLimit: 500,
    callsLimit: -1,   // unlimited
    assistantsLimit: 10,
    phoneNumbersLimit: -1 // unlimited
  },
  ENTERPRISE: {
    name: 'ENTERPRISE',
    stripePriceId: process.env.STRIPE_ENTERPRISE_PRICE_ID || 'price_enterprise',
    iyzicoPlanRef: process.env.IYZICO_ENTERPRISE_PLAN_REF,
    price: null,      // Contact sales
    priceTRY: null,   // Ä°letiÅŸime geÃ§in
    minutesLimit: -1, // unlimited (custom)
    callsLimit: -1,
    assistantsLimit: -1, // unlimited
    phoneNumbersLimit: -1 // custom
  }
};

// ============================================================================
// WEBHOOK - MUST BE FIRST (before express.json middleware)
// ============================================================================

router.post('/webhook', express.raw({ type: 'application/json' }), async (req, res) => {
  const sig = req.headers['stripe-signature'];
  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;

  let event;

  try {
    event = getStripe().webhooks.constructEvent(req.body, sig, webhookSecret);
  } catch (err) {
    console.error('âŒ Webhook signature verification failed:', err.message);
    return res.status(400).send(`Webhook Error: ${err.message}`);
  }

  console.log('âœ… Webhook received:', event.type);

  try {
    switch (event.type) {
      case 'checkout.session.completed': {
        const session = event.data.object;
        console.log('ðŸ’³ Checkout completed:', session.id);
        console.log('ðŸ“‹ Session metadata:', JSON.stringify(session.metadata));

        // Check if this is an enterprise payment link
        // Try session metadata first, then line items
        let isEnterprise = session.metadata?.type === 'enterprise';
        let subscriptionId = session.metadata?.subscriptionId ? parseInt(session.metadata.subscriptionId) : null;

        // If no metadata on session, check if we can identify from line items or price
        if (!isEnterprise && session.subscription) {
          // Get the Stripe subscription to check price metadata
          try {
            const stripeSubscription = await getStripe().subscriptions.retrieve(session.subscription);
            const priceId = stripeSubscription.items?.data?.[0]?.price?.id;

            if (priceId) {
              // Check price metadata
              const price = await getStripe().prices.retrieve(priceId);
              console.log('ðŸ’° Price metadata:', JSON.stringify(price.metadata));

              if (price.metadata?.type === 'enterprise') {
                isEnterprise = true;
                subscriptionId = parseInt(price.metadata.subscriptionId);
                console.log('ðŸ” Found enterprise info from price metadata');
              }
            }
          } catch (e) {
            console.log('âš ï¸ Could not retrieve subscription/price details:', e.message);
          }
        }

        if (isEnterprise && subscriptionId) {
          const stripeSubId = session.subscription; // Stripe subscription ID from checkout
          console.log('ðŸ’¼ Enterprise payment link completed for subscription:', subscriptionId);

          // Ã–nce mevcut subscription'Ä± al - enterprise detaylarÄ±nÄ± korumak iÃ§in
          const existingSub = await prisma.subscription.findUnique({
            where: { id: subscriptionId }
          });

          if (!existingSub) {
            console.error('âŒ Enterprise subscription not found:', subscriptionId);
            break;
          }

          // Ã–deme yapÄ±ldÄ± - pendingPlanId'yi aktif plan yap
          // Enterprise Ã¶zellikleri (dakika, concurrent vs.) aktif olacak
          await prisma.subscription.update({
            where: { id: subscriptionId },
            data: {
              plan: 'ENTERPRISE', // Åžimdi plan deÄŸiÅŸiyor
              pendingPlanId: null, // Bekleyen plan temizlendi
              enterprisePaymentStatus: 'paid',
              status: 'ACTIVE',
              stripeSubscriptionId: stripeSubId,
              stripeCustomerId: session.customer,
              currentPeriodStart: new Date(),
              currentPeriodEnd: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days
              // Enterprise limitleri aktif et
              minutesLimit: existingSub.enterpriseMinutes || 1000,
              concurrentLimit: existingSub.enterpriseConcurrent || 10,
              assistantsLimit: existingSub.enterpriseAssistants || 999
            }
          });

          console.log('âœ… Enterprise subscription payment confirmed, plan activated. Stripe Sub:', stripeSubId);
          break;
        }

        // Regular subscription checkout
        const stripeSubscriptionId = session.subscription;
        const customerId = session.customer;
        const priceId = session.line_items?.data[0]?.price?.id || session.metadata?.priceId;

        // Determine plan from price ID
        let plan = 'STARTER';
        if (priceId === PLAN_CONFIG.PRO.stripePriceId) plan = 'PRO';
        if (priceId === PLAN_CONFIG.ENTERPRISE.stripePriceId) plan = 'ENTERPRISE';

        const planConfig = PLAN_CONFIG[plan];

        // Update subscription in database
        const subscription = await prisma.subscription.updateMany({
          where: { stripeCustomerId: customerId },
          data: {
            stripeSubscriptionId: stripeSubscriptionId,
            stripePriceId: priceId,
            plan: plan,
            status: 'ACTIVE',
            currentPeriodStart: new Date(),
            currentPeriodEnd: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
            // Set plan limits
            minutesLimit: planConfig.minutesLimit,
            callsLimit: planConfig.callsLimit,
            assistantsLimit: planConfig.assistantsLimit,
            phoneNumbersLimit: planConfig.phoneNumbersLimit
          }
        });

        // Get business ID
        const sub = await prisma.subscription.findFirst({
          where: { stripeCustomerId: customerId },
          include: {
            business: {
              select: {
                id: true,
                name: true,
                users: {
                  where: { role: 'OWNER' },
                  select: { email: true },
                  take: 1
                }
              }
            }
          }
        });

        if (sub && sub.business) {
          const businessId = sub.business.id;
          const ownerEmail = sub.business.users[0]?.email;

          // Note: Phone numbers are now provisioned manually via the Phone Numbers page
          // Users can add 11Labs phone numbers after subscription activation

          // Send payment success email
          if (ownerEmail) {
            await emailService.sendPaymentSuccessEmail(
              ownerEmail,
              sub.business.name,
              planConfig.price * 100,
              plan
            );
          }
        }

        console.log('âœ… Subscription activated:', plan);
        break;
      }

      case 'customer.subscription.updated': {
        const subscription = event.data.object;
        console.log('ðŸ”„ Subscription updated:', subscription.id);

        const priceId = subscription.items.data[0]?.price?.id;
        let plan = 'STARTER';
        if (priceId === PLAN_CONFIG.PRO.stripePriceId) plan = 'PRO';
        if (priceId === PLAN_CONFIG.ENTERPRISE.stripePriceId) plan = 'ENTERPRISE';

        const planConfig = PLAN_CONFIG[plan];

        await prisma.subscription.updateMany({
          where: { stripeSubscriptionId: subscription.id },
          data: {
            plan: plan,
            status: subscription.status.toUpperCase(),
            stripePriceId: priceId,
            currentPeriodStart: new Date(subscription.current_period_start * 1000),
            currentPeriodEnd: new Date(subscription.current_period_end * 1000),
            cancelAtPeriodEnd: subscription.cancel_at_period_end,
            // Update limits
            minutesLimit: planConfig.minutesLimit,
            callsLimit: planConfig.callsLimit,
            assistantsLimit: planConfig.assistantsLimit,
            phoneNumbersLimit: planConfig.phoneNumbersLimit
          }
        });

        console.log('âœ… Subscription plan updated to:', plan);
        break;
      }

      case 'customer.subscription.created': {
        const subscription = event.data.object;
        console.log('ðŸ†• Subscription created:', subscription.id);

        // Check if this is an enterprise subscription
        const priceId = subscription.items?.data?.[0]?.price?.id;
        if (priceId) {
          try {
            const price = await getStripe().prices.retrieve(priceId);
            console.log('ðŸ’° New subscription price metadata:', JSON.stringify(price.metadata));

            if (price.metadata?.type === 'enterprise' && price.metadata?.subscriptionId) {
              const subscriptionId = parseInt(price.metadata.subscriptionId);
              console.log('ðŸ’¼ Enterprise subscription created for:', subscriptionId);

              // Get existing subscription
              const existingSub = await prisma.subscription.findUnique({
                where: { id: subscriptionId }
              });

              if (existingSub && existingSub.pendingPlanId === 'ENTERPRISE') {
                // Activate enterprise plan
                await prisma.subscription.update({
                  where: { id: subscriptionId },
                  data: {
                    plan: 'ENTERPRISE',
                    pendingPlanId: null,
                    enterprisePaymentStatus: 'paid',
                    status: 'ACTIVE',
                    stripeSubscriptionId: subscription.id,
                    stripeCustomerId: subscription.customer,
                    currentPeriodStart: new Date(subscription.current_period_start * 1000),
                    currentPeriodEnd: new Date(subscription.current_period_end * 1000),
                    minutesLimit: existingSub.enterpriseMinutes || 1000,
                    concurrentLimit: existingSub.enterpriseConcurrent || 10,
                    assistantsLimit: existingSub.enterpriseAssistants || 999
                  }
                });
                console.log('âœ… Enterprise plan activated via customer.subscription.created');
              }
            }
          } catch (e) {
            console.log('âš ï¸ Could not process new subscription:', e.message);
          }
        }
        break;
      }

      case 'customer.subscription.deleted': {
        const subscription = event.data.object;
        console.log('âŒ Subscription canceled:', subscription.id);

        // Downgrade to FREE plan
        await prisma.subscription.updateMany({
          where: { stripeSubscriptionId: subscription.id },
          data: {
            plan: 'FREE',
            status: 'CANCELED',
            stripeSubscriptionId: null,
            stripePriceId: null,
            // Reset limits to FREE
            minutesLimit: 0,
            callsLimit: 0,
            assistantsLimit: 0,
            phoneNumbersLimit: 0
          }
        });

        console.log('âœ… Downgraded to FREE plan');
        break;
      }

      case 'invoice.payment_succeeded': {
        const invoice = event.data.object;
        console.log('âœ… Payment succeeded:', invoice.id);
        console.log('ðŸ“‹ Invoice metadata:', JSON.stringify(invoice.metadata || {}));
        console.log('ðŸ“‹ Invoice subscription:', invoice.subscription);

        // Check if this is an enterprise subscription payment
        if (invoice.subscription) {
          try {
            const stripeSubscription = await getStripe().subscriptions.retrieve(invoice.subscription);
            const priceId = stripeSubscription.items?.data?.[0]?.price?.id;

            if (priceId) {
              const price = await getStripe().prices.retrieve(priceId);
              console.log('ðŸ’° Invoice price metadata:', JSON.stringify(price.metadata));

              if (price.metadata?.type === 'enterprise' && price.metadata?.subscriptionId) {
                const subscriptionId = parseInt(price.metadata.subscriptionId);
                console.log('ðŸ’¼ Enterprise invoice payment for subscription:', subscriptionId);

                // Get existing subscription
                const existingSub = await prisma.subscription.findUnique({
                  where: { id: subscriptionId }
                });

                if (existingSub && existingSub.plan !== 'ENTERPRISE') {
                  // Activate enterprise plan if not already active
                  await prisma.subscription.update({
                    where: { id: subscriptionId },
                    data: {
                      plan: 'ENTERPRISE',
                      pendingPlanId: null,
                      enterprisePaymentStatus: 'paid',
                      status: 'ACTIVE',
                      stripeSubscriptionId: invoice.subscription,
                      stripeCustomerId: invoice.customer,
                      currentPeriodStart: new Date(),
                      currentPeriodEnd: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
                      minutesLimit: existingSub.enterpriseMinutes || 1000,
                      concurrentLimit: existingSub.enterpriseConcurrent || 10,
                      assistantsLimit: existingSub.enterpriseAssistants || 999
                    }
                  });
                  console.log('âœ… Enterprise plan activated via invoice.payment_succeeded');
                }
                break;
              }
            }
          } catch (e) {
            console.log('âš ï¸ Could not check enterprise status:', e.message);
          }
        }

        // Regular payment - just update status
        await prisma.subscription.updateMany({
          where: { stripeCustomerId: invoice.customer },
          data: { status: 'ACTIVE' }
        });
        break;
      }

      case 'invoice.payment_failed': {
        const invoice = event.data.object;
        console.log('âŒ Payment failed:', invoice.id);

        await prisma.subscription.updateMany({
          where: { stripeCustomerId: invoice.customer },
          data: { status: 'PAST_DUE' }
        });

        // Get owner email and send notification
        const sub = await prisma.subscription.findFirst({
          where: { stripeCustomerId: invoice.customer },
          include: {
            business: {
              select: {
                name: true,
                users: {
                  where: { role: 'OWNER' },
                  select: { email: true },
                  take: 1
                }
              }
            }
          }
        });

        if (sub?.business.users[0]?.email) {
          await emailService.sendPaymentFailedEmail(
            sub.business.users[0].email,
            sub.business.name
          );
        }
        break;
      }

      default:
        console.log(`â„¹ï¸ Unhandled event type: ${event.type}`);
    }

    res.json({ received: true });
  } catch (error) {
    console.error('âŒ Webhook handler error:', error);
    res.status(500).json({ error: 'Webhook handler failed' });
  }
});

// ============================================================================
// IYZICO WEBHOOK
// ============================================================================

router.post('/iyzico-webhook', express.json(), async (req, res) => {
  console.log('ðŸ“¥ iyzico webhook received', {
    webhookType: req.body?.iyziEventType || req.body?.status || 'unknown',
    hasToken: Boolean(req.body?.token),
    hasConversationId: Boolean(req.body?.conversationId),
  });

  try {
    const result = await iyzicoSubscription.processWebhook(req.body);

    if (result.success) {
      res.json({ received: true });
    } else {
      console.error('âŒ iyzico webhook processing failed:', result.error);
      res.status(400).json({ error: result.error });
    }
  } catch (error) {
    console.error('âŒ iyzico webhook error:', error);
    res.status(500).json({ error: 'Webhook handler failed' });
  }
});

// ============================================================================
// IYZICO PAYMENT CALLBACK (Simple checkout - not subscription)
// ============================================================================

router.post('/iyzico-payment-callback', async (req, res) => {
  const { token } = req.body;
  const { planId, businessId } = req.query;
  const frontendUrl = process.env.FRONTEND_URL;

  console.log('ðŸ“¥ iyzico payment callback received:', {
    hasToken: Boolean(token),
    planId,
    businessId
  });

  if (!token) {
    return res.redirect(`${frontendUrl}/pricing?error=missing_token`);
  }

  try {
    // Retrieve checkout form result
    const Iyzipay = (await import('iyzipay')).default;
    const iyzipay = new Iyzipay({
      apiKey: process.env.IYZICO_API_KEY,
      secretKey: process.env.IYZICO_SECRET_KEY,
      uri: process.env.IYZICO_BASE_URL || 'https://sandbox-api.iyzipay.com'
    });

    const request = {
      locale: Iyzipay.LOCALE.TR,
      conversationId: `callback-${Date.now()}`,
      token: token
    };

    iyzipay.checkoutForm.retrieve(request, async (err, result) => {
      if (err) {
        console.error('iyzico retrieve error:', err);
        return res.redirect(`${frontendUrl}/pricing?error=payment_failed`);
      }

      console.log('iyzico payment result:', result.status, result.paymentStatus);

      if (result.status === 'success' && result.paymentStatus === 'SUCCESS') {
        // Payment successful - activate subscription
        const planConfig = PLAN_CONFIG[planId];

        if (planConfig && businessId) {
          await prisma.subscription.upsert({
            where: { businessId: parseInt(businessId) },
            create: {
              businessId: parseInt(businessId),
              paymentProvider: 'iyzico',
              iyzicoPaymentId: result.paymentId,
              plan: planId,
              status: 'ACTIVE',
              currentPeriodStart: new Date(),
              currentPeriodEnd: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
              minutesLimit: planConfig.minutesLimit,
              callsLimit: planConfig.callsLimit,
              assistantsLimit: planConfig.assistantsLimit,
              phoneNumbersLimit: planConfig.phoneNumbersLimit
            },
            update: {
              paymentProvider: 'iyzico',
              iyzicoPaymentId: result.paymentId,
              plan: planId,
              status: 'ACTIVE',
              currentPeriodStart: new Date(),
              currentPeriodEnd: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
              minutesLimit: planConfig.minutesLimit,
              callsLimit: planConfig.callsLimit,
              assistantsLimit: planConfig.assistantsLimit,
              phoneNumbersLimit: planConfig.phoneNumbersLimit
            }
          });

          console.log('âœ… iyzico payment successful, plan activated:', planId);
        }

        return res.redirect(`${frontendUrl}/dashboard/assistant?success=true&provider=iyzico`);
      } else {
        console.log('âŒ iyzico payment failed:', result.errorMessage);
        return res.redirect(`${frontendUrl}/pricing?error=payment_failed&message=${encodeURIComponent(result.errorMessage || 'Ã–deme baÅŸarÄ±sÄ±z')}`);
      }
    });
  } catch (error) {
    console.error('iyzico callback error:', error);
    return res.redirect(`${frontendUrl}/pricing?error=callback_failed`);
  }
});

// iyzico Subscription Callback - POST handler for form submission
router.post('/iyzico-subscription-callback', async (req, res) => {
  const { token } = req.body;
  const frontendUrl = process.env.FRONTEND_URL;

  console.log('ðŸ“¥ iyzico subscription callback received', { tokenHash: hashValue(token) });

  if (!token) {
    return res.redirect(`${frontendUrl}/dashboard/subscription?status=error&message=missing_token`);
  }

  try {
    // Retrieve subscription checkout form result using iyzicoSubscription service
    const result = await iyzicoSubscription.retrieveCheckoutFormResult(token);

    if (!result.success) {
      console.error('iyzico callback error:', result.error);
      return res.redirect(`${frontendUrl}/dashboard/subscription?status=error`);
    }

    console.log('iyzico subscription result received', {
      success: Boolean(result?.success),
      reference: result?.subscriptionReferenceCode ? hashValue(result.subscriptionReferenceCode) : null
    });

    // Find subscription by pending token
    const subscription = await prisma.subscription.findFirst({
      where: { pendingSubscriptionToken: token }
    });

    if (subscription) {
      const planId = subscription.pendingPlanId;
      const planConfig = PLAN_CONFIG[planId] || PLAN_CONFIG.STARTER;

      await prisma.subscription.update({
        where: { id: subscription.id },
        data: {
          plan: planId,
          status: 'ACTIVE',
          paymentProvider: 'iyzico',
          iyzicoSubscriptionId: result.subscriptionReferenceCode,
          iyzicoReferenceCode: result.subscriptionReferenceCode,
          currentPeriodStart: new Date(result.startDate),
          currentPeriodEnd: new Date(result.endDate),
          pendingSubscriptionToken: null,
          pendingPlanId: null,
          // Set plan limits
          minutesLimit: planConfig.minutesLimit,
          callsLimit: planConfig.callsLimit,
          assistantsLimit: planConfig.assistantsLimit,
          phoneNumbersLimit: planConfig.phoneNumbersLimit
        }
      });

      console.log('âœ… iyzico subscription activated:', planId);
    }

    return res.redirect(`${frontendUrl}/dashboard/subscription?status=success`);
  } catch (error) {
    console.error('iyzico subscription callback error:', error);
    return res.redirect(`${frontendUrl}/dashboard/subscription?status=error`);
  }
});

// iyzico callback - POST handler (used by iyzicoSubscription service)
router.post('/iyzico-callback', async (req, res) => {
  const { token } = req.body;
  const frontendUrl = process.env.FRONTEND_URL;

  console.log('ðŸ“¥ iyzico callback received', { tokenHash: hashValue(token) });

  if (!token) {
    return res.redirect(`${frontendUrl}/dashboard/subscription?status=error&message=missing_token`);
  }

  try {
    // Retrieve subscription checkout form result using iyzicoSubscription service
    const result = await iyzicoSubscription.retrieveCheckoutFormResult(token);

    if (!result.success) {
      console.error('iyzico callback error:', result.error);
      return res.redirect(`${frontendUrl}/dashboard/subscription?status=error`);
    }

    console.log('iyzico subscription result received', {
      success: Boolean(result?.success),
      reference: result?.subscriptionReferenceCode ? hashValue(result.subscriptionReferenceCode) : null
    });

    // Find subscription by pending token
    const subscription = await prisma.subscription.findFirst({
      where: { pendingSubscriptionToken: token }
    });

    if (subscription) {
      const planId = subscription.pendingPlanId;
      const planConfig = PLAN_CONFIG[planId] || PLAN_CONFIG.STARTER;

      await prisma.subscription.update({
        where: { id: subscription.id },
        data: {
          plan: planId,
          status: 'ACTIVE',
          paymentProvider: 'iyzico',
          iyzicoSubscriptionId: result.subscriptionReferenceCode,
          iyzicoReferenceCode: result.subscriptionReferenceCode,
          currentPeriodStart: new Date(result.startDate),
          currentPeriodEnd: new Date(result.endDate),
          pendingSubscriptionToken: null,
          pendingPlanId: null,
          // Set plan limits
          minutesLimit: planConfig.minutesLimit,
          callsLimit: planConfig.callsLimit,
          assistantsLimit: planConfig.assistantsLimit,
          phoneNumbersLimit: planConfig.phoneNumbersLimit
        }
      });

      console.log('âœ… iyzico subscription activated:', planId);
    }

    return res.redirect(`${frontendUrl}/dashboard/subscription?status=success`);
  } catch (error) {
    console.error('iyzico callback error:', error);
    return res.redirect(`${frontendUrl}/dashboard/subscription?status=error`);
  }
});

// Legacy callback (GET - for backward compatibility)
router.get('/iyzico-callback', async (req, res) => {
  const frontendUrl = process.env.FRONTEND_URL;
  return res.redirect(`${frontendUrl}/dashboard/subscription?status=error&message=use_post`);
});

// ============================================================================
// PUBLIC ROUTES (no auth required)
// ============================================================================

// Get available plans - PUBLIC (used by pricing page before login)
// Updated: January 2026 - synced with pricing.js
router.get('/plans', async (req, res) => {
  try {
    const plans = [
      {
        id: 'FREE',
        name: 'Free',
        price: 0,
        priceTRY: 0,
        currency: 'USD',
        interval: 'month',
        features: [
          'Web voice test only (60s limit)',
          '3 AI trainings',
          '0 permanent assistants',
          'No phone number',
          'No integrations',
          'No analytics'
        ],
        limits: PLAN_CONFIG.FREE
      },
      {
        id: 'PAYG',
        name: 'Pay As You Go',
        nameTR: 'KullandÄ±kÃ§a Ã–de',
        price: 0,
        priceTRY: 0,
        currency: 'USD',
        interval: 'month',
        isPrepaid: true,
        features: [
          '1 AI assistant',
          '1 phone number',
          'Pay per minute (balance-based)',
          'Unlimited calls',
          'Unlimited trainings',
          'Basic analytics',
          'All integrations',
          'Email support'
        ],
        limits: PLAN_CONFIG.PAYG
      },
      {
        id: 'STARTER',
        name: 'Starter',
        nameTR: 'BaÅŸlangÄ±Ã§',
        price: 55,          // $55 USD
        priceTRY: 2499,     // â‚º2.499 TRY
        currency: 'USD',
        interval: 'month',
        stripePriceId: PLAN_CONFIG.STARTER.stripePriceId,
        iyzicoPlanRef: PLAN_CONFIG.STARTER.iyzicoPlanRef,
        popular: true,
        features: [
          '3 AI assistants',
          'Unlimited phone numbers',
          '150 minutes per month',
          'Unlimited calls',
          'Unlimited trainings',
          'Basic analytics',
          'All integrations',
          'Email support',
          'Overage: 23â‚º/min'
        ],
        limits: PLAN_CONFIG.STARTER
      },
      {
        id: 'PRO',
        name: 'Pro',
        nameTR: 'Profesyonel',
        price: 167,         // $167 USD
        priceTRY: 7499,     // â‚º7.499 TRY
        currency: 'USD',
        interval: 'month',
        stripePriceId: PLAN_CONFIG.PRO.stripePriceId,
        iyzicoPlanRef: PLAN_CONFIG.PRO?.iyzicoPlanRef,
        bestValue: true,
        features: [
          '10 AI assistants',
          'Unlimited phone numbers',
          '500 minutes per month',
          'Unlimited calls',
          'Unlimited trainings',
          'Advanced analytics with AI insights',
          'All integrations',
          'Batch/outbound calls',
          'Priority support',
          'API access',
          'Overage: 23â‚º/min'
        ],
        limits: PLAN_CONFIG.PRO
      },
      {
        id: 'ENTERPRISE',
        name: 'Enterprise',
        nameTR: 'Kurumsal',
        price: null,
        priceTRY: null,
        currency: 'USD',
        interval: 'month',
        contactSales: true,
        stripePriceId: PLAN_CONFIG.ENTERPRISE.stripePriceId,
        iyzicoPlanRef: PLAN_CONFIG.ENTERPRISE.iyzicoPlanRef,
        features: [
          'Unlimited AI assistants',
          'Unlimited phone numbers',
          'Custom minutes allocation',
          'Custom voice cloning',
          'White-label option',
          'Dedicated account manager',
          'SLA guarantee',
          'Custom integrations'
        ],
        limits: PLAN_CONFIG.ENTERPRISE
      }
    ];

    res.json(plans);
  } catch (error) {
    console.error('Get plans error:', error);
    res.status(500).json({ error: 'Failed to get plans' });
  }
});

// ============================================================================
// AUTHENTICATED ROUTES
// ============================================================================

router.use(authenticateToken);

// Get current subscription
router.get('/current', verifyBusinessAccess, async (req, res) => {
  try {
    const { businessId } = req.user;

    const subscription = await prisma.subscription.findUnique({
      where: { businessId },
      include: {
        business: {
          select: {
            phoneNumbers: true,
            country: true,
            phoneInboundEnabled: true
          }
        }
      }
    });

    if (!subscription) {
      const entitlements = buildPhoneEntitlements({
        plan: 'FREE',
        inboundEnabled: false
      });

      return res.json({
        plan: 'FREE',
        status: 'TRIAL',
        entitlements,
        usage: {
          minutes: { used: 0, limit: 0 },
          calls: { used: 0, limit: 0 },
          assistants: { used: 0, limit: 0 },
          phoneNumbers: { used: 0, limit: 0 }
        }
      });
    }

    const effectivePlanConfig = getEffectivePlanConfig(subscription);
    const effectiveInboundEnabled = isPhoneInboundEnabledForBusinessRecord(subscription.business);
    const entitlements = buildPhoneEntitlements({
      plan: subscription.plan,
      inboundEnabled: effectiveInboundEnabled
    });
    const effectiveMinutesLimit = effectivePlanConfig.includedMinutes ?? subscription.minutesLimit;
    const effectiveAssistantsLimit = effectivePlanConfig.assistantsLimit ?? subscription.assistantsLimit;
    const effectivePhoneNumbersLimit = effectivePlanConfig.phoneNumbersLimit ?? subscription.phoneNumbersLimit;
    const effectiveConcurrentLimit = effectivePlanConfig.concurrentLimit ?? subscription.concurrentLimit;

    // Calculate usage percentages
    const response = {
      ...subscription,
      entitlements,
      limits: {
        minutes: effectiveMinutesLimit,
        assistants: effectiveAssistantsLimit,
        phoneNumbers: effectivePhoneNumbersLimit,
        concurrent: effectiveConcurrentLimit,
        overageRate: effectivePlanConfig.overageRate ?? subscription.overageRate,
        outbound: {
          testCallEnabled: entitlements.outbound?.testCall?.enabled ?? false,
          campaignsEnabled: entitlements.outbound?.campaigns?.enabled ?? false,
          campaignsRequiredPlan: entitlements.outbound?.campaigns?.requiredPlan || null
        }
      },
      usage: {
        minutes: {
          used: subscription.minutesUsed,
          limit: effectiveMinutesLimit,
          percentage: effectiveMinutesLimit > 0
            ? Math.round((subscription.minutesUsed / effectiveMinutesLimit) * 100)
            : 0,
          unlimited: effectiveMinutesLimit === -1 || effectiveMinutesLimit === null
        },
        calls: {
          used: subscription.callsThisMonth,
          limit: subscription.callsLimit,
          percentage: subscription.callsLimit > 0
            ? Math.round((subscription.callsThisMonth / subscription.callsLimit) * 100)
            : 0,
          unlimited: subscription.callsLimit === -1
        },
        assistants: {
          used: subscription.assistantsCreated,
          limit: effectiveAssistantsLimit
        },
        phoneNumbers: {
          used: subscription.business.phoneNumbers?.length || 0,
          limit: effectivePhoneNumbersLimit
        }
      }
    };

    res.json(response);
  } catch (error) {
    console.error('Get subscription error:', error);
    res.status(500).json({ error: 'Failed to get subscription' });
  }
});

// Get payment provider for current business
router.get('/payment-provider', verifyBusinessAccess, async (req, res) => {
  try {
    const { businessId } = req.user;
    const provider = await paymentProvider.getProviderForBusiness(businessId);

    const business = await prisma.business.findUnique({
      where: { id: businessId },
      select: { country: true }
    });

    res.json({
      provider,
      country: business?.country || 'TR',
      isIyzico: provider === 'iyzico',
      isStripe: provider === 'stripe'
    });
  } catch (error) {
    console.error('Get payment provider error:', error);
    res.status(500).json({ error: 'Failed to get payment provider' });
  }
});

// Create checkout session - Automatically selects Stripe or iyzico based on country
router.post('/create-checkout', verifyBusinessAccess, async (req, res) => {
  try {
    const { businessId } = req.user;
    const { priceId, planId, forceProvider } = req.body;

    if (!priceId && !planId) {
      return res.status(400).json({ error: 'Price ID or Plan ID required' });
    }

    // Get business to determine provider
    const user = await prisma.user.findFirst({
      where: { businessId },
      include: { business: true }
    });

    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    // Determine payment provider (can be forced or auto-detected)
    const provider = forceProvider || paymentProvider.getProviderForCountry(user.business.country);

    console.log(`ðŸ’³ Creating checkout for business ${businessId} with provider: ${provider} (country: ${user.business.country})`);

    // ========== IYZICO CHECKOUT ==========
    if (provider === 'iyzico') {
      const finalPlanId = planId || Object.keys(PLAN_CONFIG).find(
        key => PLAN_CONFIG[key].stripePriceId === priceId
      );

      if (!finalPlanId || finalPlanId === 'FREE') {
        return res.status(400).json({ error: 'Invalid plan for iyzico' });
      }

      const result = await iyzicoSubscription.initializeCheckoutForm(businessId, finalPlanId);

      if (!result.success) {
        return res.status(400).json({
          error: 'Failed to initialize iyzico checkout',
          details: result.error
        });
      }

      return res.json({
        provider: 'iyzico',
        checkoutFormContent: result.checkoutFormContent,
        token: result.token,
        tokenExpireTime: result.tokenExpireTime
      });
    }

    // ========== STRIPE CHECKOUT ==========
    // Get price ID from plan ID if not provided
    let finalPriceId = priceId;
    if (!finalPriceId && planId) {
      finalPriceId = PLAN_CONFIG[planId]?.stripePriceId;
    }

    if (!finalPriceId) {
      return res.status(400).json({ error: 'Invalid plan or price ID' });
    }

    // Get or create Stripe customer
    let stripeCustomerId;
    const existingSub = await prisma.subscription.findUnique({
      where: { businessId }
    });

    if (existingSub?.stripeCustomerId) {
      stripeCustomerId = existingSub.stripeCustomerId;
    } else {
      const customer = await getStripe().customers.create({
        email: user.email,
        name: user.business.name,
        metadata: {
          businessId: businessId.toString()
        }
      });
      stripeCustomerId = customer.id;

      // Save customer ID
      await prisma.subscription.upsert({
        where: { businessId },
        create: {
          businessId,
          stripeCustomerId,
          paymentProvider: 'stripe',
          plan: 'FREE',
          status: 'INCOMPLETE'
        },
        update: {
          stripeCustomerId,
          paymentProvider: 'stripe'
        }
      });
    }

    // Create checkout session
    const frontendUrl = process.env.FRONTEND_URL;
    const session = await getStripe().checkout.sessions.create({
      customer: stripeCustomerId,
      mode: 'subscription',
      payment_method_types: ['card'],
      line_items: [
        {
          price: finalPriceId,
          quantity: 1
        }
      ],
      success_url: `${frontendUrl}/dashboard/assistant?success=true&provider=stripe`,
      cancel_url: `${frontendUrl}/pricing?canceled=true`,
      metadata: {
        businessId: businessId.toString(),
        priceId: finalPriceId
      }
    });

    res.json({
      provider: 'stripe',
      sessionUrl: session.url,
      sessionId: session.id
    });
  } catch (error) {
    console.error('Create checkout error:', error);
    res.status(500).json({
      error: 'Failed to create checkout',
      details: error.message
    });
  }
});

// Cancel subscription - supports both Stripe and iyzico
router.post('/cancel', verifyBusinessAccess, async (req, res) => {
  try {
    const { businessId } = req.user;

    const subscription = await prisma.subscription.findUnique({
      where: { businessId }
    });

    if (!subscription) {
      return res.status(400).json({ error: 'No subscription found' });
    }

    // Handle based on payment provider
    if (subscription.paymentProvider === 'iyzico' && subscription.iyzicoSubscriptionId) {
      // Cancel iyzico subscription
      const result = await iyzicoSubscription.cancelSubscription(subscription.iyzicoSubscriptionId);

      if (!result.success) {
        return res.status(400).json({ error: result.error || 'Failed to cancel iyzico subscription' });
      }

      await prisma.subscription.update({
        where: { businessId },
        data: {
          cancelAtPeriodEnd: true
        }
      });

      return res.json({
        success: true,
        provider: 'iyzico',
        message: 'AboneliÄŸiniz iptal edildi'
      });
    }

    // Stripe cancellation
    if (!subscription.stripeSubscriptionId) {
      return res.status(400).json({ error: 'No active subscription' });
    }

    // Cancel at period end (don't cancel immediately)
    await getStripe().subscriptions.update(subscription.stripeSubscriptionId, {
      cancel_at_period_end: true
    });

    // Update database
    await prisma.subscription.update({
      where: { businessId },
      data: {
        cancelAtPeriodEnd: true
      }
    });

    res.json({
      success: true,
      provider: 'stripe',
      message: 'Subscription will be canceled at the end of the current period'
    });
  } catch (error) {
    console.error('Cancel subscription error:', error);
    res.status(500).json({ error: 'Failed to cancel subscription' });
  }
});

// Reactivate canceled subscription
router.post('/reactivate', verifyBusinessAccess, async (req, res) => {
  try {
    const { businessId } = req.user;

    const subscription = await prisma.subscription.findUnique({
      where: { businessId }
    });

    if (!subscription) {
      return res.status(400).json({ error: 'No subscription found' });
    }

    // Handle based on payment provider
    if (subscription.paymentProvider === 'iyzico') {
      // iyzico doesn't support reactivation the same way
      // User needs to create a new subscription
      return res.status(400).json({
        error: 'iyzico subscriptions cannot be reactivated. Please create a new subscription.',
        needsNewSubscription: true
      });
    }

    // Stripe reactivation
    if (!subscription.stripeSubscriptionId) {
      return res.status(400).json({ error: 'No subscription found' });
    }

    // Remove cancel_at_period_end
    await getStripe().subscriptions.update(subscription.stripeSubscriptionId, {
      cancel_at_period_end: false
    });

    await prisma.subscription.update({
      where: { businessId },
      data: {
        cancelAtPeriodEnd: false
      }
    });

    res.json({
      success: true,
      message: 'Subscription reactivated'
    });
  } catch (error) {
    console.error('Reactivate subscription error:', error);
    res.status(500).json({ error: 'Failed to reactivate subscription' });
  }
});

// ============================================================================
// UPGRADE ENDPOINT - iyzico Subscription API with Plan References
// ============================================================================

router.post('/upgrade', verifyBusinessAccess, async (req, res) => {
  try {
    const { businessId } = req.user;
    const { planId } = req.body;

    if (!planId) {
      return res.status(400).json({ error: 'Plan ID is required' });
    }

    // Normalize planId to uppercase and map aliases
    let normalizedPlanId = planId.toUpperCase();

    // Map common aliases (BASIC is legacy alias for STARTER)
    const planAliases = {
      'BASIC': 'STARTER'
    };
    normalizedPlanId = planAliases[normalizedPlanId] || normalizedPlanId;

    if (!PLAN_CONFIG[normalizedPlanId] || normalizedPlanId === 'FREE') {
      return res.status(400).json({ error: 'Invalid plan ID' });
    }

    // Handle PAYG plan switch - redirect to switch-to-payg endpoint
    if (normalizedPlanId === 'PAYG') {
      // PAYG is balance-based, not subscription-based
      const planConfig = PLAN_CONFIG.PAYG;

      // Update subscription to PAYG plan
      await prisma.subscription.upsert({
        where: { businessId },
        create: {
          businessId,
          plan: 'PAYG',
          status: 'ACTIVE',
          balance: 0,
          minutesLimit: planConfig.minutesLimit,
          callsLimit: planConfig.callsLimit,
          assistantsLimit: planConfig.assistantsLimit,
          phoneNumbersLimit: planConfig.phoneNumbersLimit
        },
        update: {
          plan: 'PAYG',
          status: 'ACTIVE',
          cancelAtPeriodEnd: false,
          minutesLimit: planConfig.minutesLimit,
          callsLimit: planConfig.callsLimit,
          assistantsLimit: planConfig.assistantsLimit,
          phoneNumbersLimit: planConfig.phoneNumbersLimit
        }
      });

      console.log(`âœ… Switched to PAYG for business ${businessId}`);

      return res.json({
        success: true,
        message: 'KullandÄ±kÃ§a Ã¶de planÄ±na geÃ§ildi. Bakiye yÃ¼kleyerek kullanmaya baÅŸlayabilirsiniz.',
        type: 'payg_switch'
      });
    }

    // Get user and business info
    const user = await prisma.user.findFirst({
      where: { businessId },
      include: { business: true }
    });

    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    // Determine payment provider based on country
    const provider = paymentProvider.getProviderForCountry(user.business.country);

    console.log(`ðŸ’³ Upgrade request for business ${businessId}, plan: ${normalizedPlanId}, provider: ${provider}`);

    // ========== IYZICO SUBSCRIPTION API ==========
    if (provider === 'iyzico') {
      // Use iyzicoSubscription service for checkout form initialization
      const result = await iyzicoSubscription.initializeCheckoutForm(businessId, normalizedPlanId);

      if (!result.success) {
        console.error('iyzico subscription error:', result.error);
        return res.status(500).json({ error: result.error || 'Abonelik baÅŸlatÄ±lamadÄ±' });
      }

      // Save pending subscription info
      await prisma.subscription.upsert({
        where: { businessId },
        create: {
          businessId,
          paymentProvider: 'iyzico',
          plan: 'FREE',
          status: 'INCOMPLETE',
          pendingSubscriptionToken: result.token,
          pendingPlanId: normalizedPlanId
        },
        update: {
          pendingSubscriptionToken: result.token,
          pendingPlanId: normalizedPlanId
        }
      });

      return res.json({
        provider: 'iyzico',
        checkoutFormContent: result.checkoutFormContent,
        token: result.token,
        tokenExpireTime: result.tokenExpireTime
      });
    }

    // ========== STRIPE CHECKOUT ==========
    const planConfig = PLAN_CONFIG[normalizedPlanId];

    // Determine price ID based on country
    const country = user.business.country?.toUpperCase();
    let priceId;

    if (country === 'TR') {
      // Use TRY pricing for Turkey
      priceId = process.env[`STRIPE_${normalizedPlanId}_PRICE_ID_TRY`] || planConfig.stripePriceId;
    } else {
      // Use USD pricing for other countries
      priceId = planConfig.stripePriceId;
    }

    if (!priceId) {
      return res.status(400).json({ error: 'Stripe price not configured for this plan' });
    }

    // Get or create Stripe customer
    let stripeCustomerId;
    const existingSub = await prisma.subscription.findUnique({
      where: { businessId }
    });

    if (existingSub?.stripeCustomerId) {
      stripeCustomerId = existingSub.stripeCustomerId;
    } else {
      const customer = await getStripe().customers.create({
        email: user.email,
        name: user.business.name,
        metadata: {
          businessId: businessId.toString()
        }
      });
      stripeCustomerId = customer.id;

      // Save customer ID
      await prisma.subscription.upsert({
        where: { businessId },
        create: {
          businessId,
          stripeCustomerId,
          paymentProvider: 'stripe',
          plan: 'FREE',
          status: 'INCOMPLETE'
        },
        update: {
          stripeCustomerId,
          paymentProvider: 'stripe'
        }
      });
    }

    // Check if user already has an active subscription
    const currentSubscription = await prisma.subscription.findUnique({
      where: { businessId }
    });

    const frontendUrl = process.env.FRONTEND_URL;

    // If already has subscription, update it (upgrade/downgrade)
    if (currentSubscription?.stripeSubscriptionId) {
      const stripeSubscription = await getStripe().subscriptions.retrieve(currentSubscription.stripeSubscriptionId);

      // CHECK: If subscription is canceled, reactivate it + change plan
      if (stripeSubscription.cancel_at_period_end) {
        // Reactivate subscription + change to new plan
        await getStripe().subscriptions.update(stripeSubscription.id, {
          cancel_at_period_end: false, // Undo cancellation
          items: [{
            id: stripeSubscription.items.data[0].id,
            price: priceId
          }],
          proration_behavior: 'none', // No immediate charge, will charge at next period
          metadata: {
            planId: normalizedPlanId
          }
        });

        // Update database
        await prisma.subscription.update({
          where: { businessId },
          data: {
            plan: normalizedPlanId,
            cancelAtPeriodEnd: false,
            minutesLimit: planConfig.minutesLimit,
            callsLimit: planConfig.callsLimit,
            assistantsLimit: planConfig.assistantsLimit,
            phoneNumbersLimit: planConfig.phoneNumbersLimit
          }
        });

        console.log(`âœ… Reactivated and changed plan for business ${businessId}: ${normalizedPlanId}`);

        return res.json({
          provider: 'stripe',
          success: true,
          message: 'Subscription reactivated with new plan',
          type: 'reactivate',
          effectiveDate: new Date(stripeSubscription.current_period_end * 1000)
        });
      }

      // Get current plan level
      const planLevels = { STARTER: 1, PRO: 2, ENTERPRISE: 3 };
      const currentLevel = planLevels[currentSubscription.plan] || 0;
      const newLevel = planLevels[normalizedPlanId] || 0;

      // Determine if upgrade or downgrade
      const isUpgrade = newLevel > currentLevel;

      if (isUpgrade) {
        // UPGRADE: Immediate with proration
        await getStripe().subscriptions.update(stripeSubscription.id, {
          items: [{
            id: stripeSubscription.items.data[0].id,
            price: priceId
          }],
          proration_behavior: 'create_prorations', // Charge difference now
          metadata: {
            planId: normalizedPlanId
          }
        });

        // Update database
        await prisma.subscription.update({
          where: { businessId },
          data: {
            plan: normalizedPlanId,
            minutesLimit: planConfig.minutesLimit,
            callsLimit: planConfig.callsLimit,
            assistantsLimit: planConfig.assistantsLimit,
            phoneNumbersLimit: planConfig.phoneNumbersLimit
          }
        });

        console.log(`âœ… Upgraded subscription for business ${businessId}: ${currentSubscription.plan} â†’ ${normalizedPlanId}`);

        return res.json({
          provider: 'stripe',
          success: true,
          message: 'Plan upgraded successfully',
          type: 'upgrade'
        });
      } else {
        // DOWNGRADE: Schedule for end of period
        await getStripe().subscriptions.update(stripeSubscription.id, {
          items: [{
            id: stripeSubscription.items.data[0].id,
            price: priceId
          }],
          proration_behavior: 'none', // No charge now
          billing_cycle_anchor: 'unchanged', // Keep current billing cycle
          metadata: {
            scheduledPlanId: normalizedPlanId
          }
        });

        // Mark as pending downgrade
        await prisma.subscription.update({
          where: { businessId },
          data: {
            pendingPlanId: normalizedPlanId
          }
        });

        console.log(`â° Scheduled downgrade for business ${businessId}: ${currentSubscription.plan} â†’ ${normalizedPlanId} (at period end)`);

        return res.json({
          provider: 'stripe',
          success: true,
          message: 'Plan will be downgraded at the end of current billing period',
          type: 'downgrade',
          effectiveDate: new Date(stripeSubscription.current_period_end * 1000)
        });
      }
    }

    // NEW SUBSCRIPTION: Create checkout session
    const session = await getStripe().checkout.sessions.create({
      customer: stripeCustomerId,
      mode: 'subscription',
      payment_method_types: ['card'],
      line_items: [
        {
          price: priceId,
          quantity: 1
        }
      ],
      success_url: `${frontendUrl}/dashboard/subscription?success=true&session_id={CHECKOUT_SESSION_ID}`,
      cancel_url: `${frontendUrl}/pricing?canceled=true`,
      metadata: {
        businessId: businessId.toString(),
        priceId: priceId,
        planId: normalizedPlanId
      }
    });

    return res.json({
      provider: 'stripe',
      sessionUrl: session.url,
      sessionId: session.id,
      type: 'new'
    });
  } catch (error) {
    console.error('Upgrade error:', error);
    res.status(500).json({
      error: 'Upgrade failed',
      details: error.message
    });
  }
});

// Verify Stripe checkout session and activate subscription
router.get('/verify-session', authenticateToken, async (req, res) => {
  try {
    const { session_id } = req.query;
    const { businessId } = req;

    if (!session_id) {
      return res.status(400).json({ error: 'Session ID required' });
    }

    // Retrieve the session from Stripe
    const session = await getStripe().checkout.sessions.retrieve(session_id);

    if (session.payment_status !== 'paid') {
      return res.status(400).json({ error: 'Payment not completed' });
    }

    // Get subscription details
    const stripeSubscription = await getStripe().subscriptions.retrieve(session.subscription);
    const planId = session.metadata.planId;
    const planConfig = PLAN_CONFIG[planId];

    if (!planConfig) {
      return res.status(400).json({ error: 'Invalid plan' });
    }

    // Convert Unix timestamps to Date objects
    const periodStart = stripeSubscription.current_period_start
      ? new Date(stripeSubscription.current_period_start * 1000)
      : new Date();
    const periodEnd = stripeSubscription.current_period_end
      ? new Date(stripeSubscription.current_period_end * 1000)
      : new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);

    console.log('ðŸ“… Subscription dates:', { periodStart, periodEnd });

    // Activate subscription in database
    await prisma.subscription.upsert({
      where: { businessId },
      create: {
        businessId,
        plan: planId,
        status: 'ACTIVE',
        paymentProvider: 'stripe',
        stripeCustomerId: session.customer,
        stripeSubscriptionId: session.subscription,
        currentPeriodStart: periodStart,
        currentPeriodEnd: periodEnd,
        minutesLimit: planConfig.minutesLimit,
        callsLimit: planConfig.callsLimit,
        assistantsLimit: planConfig.assistantsLimit,
        phoneNumbersLimit: planConfig.phoneNumbersLimit
      },
      update: {
        plan: planId,
        status: 'ACTIVE',
        paymentProvider: 'stripe',
        stripeSubscriptionId: session.subscription,
        currentPeriodStart: periodStart,
        currentPeriodEnd: periodEnd,
        minutesLimit: planConfig.minutesLimit,
        callsLimit: planConfig.callsLimit,
        assistantsLimit: planConfig.assistantsLimit,
        phoneNumbersLimit: planConfig.phoneNumbersLimit
      }
    });

    console.log(`âœ… Subscription activated for business ${businessId}, plan: ${planId}`);

    return res.json({
      success: true,
      plan: planId,
      status: 'ACTIVE'
    });
  } catch (error) {
    console.error('Verify session error:', error);
    return res.status(500).json({ error: 'Failed to verify session' });
  }
});

// Create portal session (for managing payment methods)
router.post('/create-portal-session', verifyBusinessAccess, async (req, res) => {
  try {
    const { businessId } = req.user;

    const subscription = await prisma.subscription.findUnique({
      where: { businessId }
    });

    if (!subscription?.stripeCustomerId) {
      return res.status(400).json({ error: 'No Stripe customer found' });
    }

    const frontendUrl = process.env.FRONTEND_URL;
    const session = await getStripe().billingPortal.sessions.create({
      customer: subscription.stripeCustomerId,
      return_url: `${frontendUrl}/dashboard/settings?tab=billing`
    });

    res.json({
      portalUrl: session.url
    });
  } catch (error) {
    console.error('Create portal session error:', error);
    res.status(500).json({ error: 'Failed to create portal session' });
  }
});

// Cancel subscription (schedules cancellation at period end)
router.post('/cancel', authenticateToken, async (req, res) => {
  try {
    const { businessId } = req;

    const subscription = await prisma.subscription.findUnique({
      where: { businessId }
    });

    if (!subscription) {
      return res.status(404).json({ error: 'No subscription found' });
    }

    if (!subscription.stripeSubscriptionId) {
      return res.status(400).json({ error: 'No Stripe subscription found' });
    }

    // Cancel at period end (user keeps access until current period ends)
    const canceledSubscription = await getStripe().subscriptions.update(
      subscription.stripeSubscriptionId,
      {
        cancel_at_period_end: true
      }
    );

    // Update database
    await prisma.subscription.update({
      where: { businessId },
      data: {
        cancelAtPeriodEnd: true
      }
    });

    console.log(`âœ… Subscription canceled at period end for business ${businessId}`);

    return res.json({
      success: true,
      message: 'Subscription will be canceled at period end',
      cancelAt: new Date(canceledSubscription.current_period_end * 1000)
    });
  } catch (error) {
    console.error('Cancel subscription error:', error);
    return res.status(500).json({
      error: 'Failed to cancel subscription',
      details: error.message
    });
  }
});

// GET /api/subscription/billing-history
router.get('/billing-history', authenticateToken, async (req, res) => {
  try {
    const { businessId } = req;

    const subscription = await prisma.subscription.findUnique({
      where: { businessId },
      include: {
        business: true
      }
    });

    if (!subscription) {
      return res.json({ history: [] });
    }

    // Mock billing history for now (Stripe webhook'tan gelecek)
    const history = [
      {
        id: 1,
        date: new Date().toISOString(),
        amount: subscription.plan === 'FREE' ? 0 : subscription.plan === 'BASIC' ? 29 : 99,
        status: 'paid',
        plan: subscription.plan,
        period: 'monthly'
      }
    ];

    res.json({ history });
  } catch (error) {
    console.error('Get billing history error:', error);
    res.status(500).json({ error: 'Failed to fetch billing history' });
  }
});

// ============================================================================
// NEW PRICING SYSTEM ENDPOINTS
// ============================================================================

// POST /api/subscription/start-trial - Start trial for new user
router.post('/start-trial', verifyBusinessAccess, async (req, res) => {
  try {
    const { businessId } = req.user;

    // Check if trial already used (check if trialMinutesUsed > 0 or trialChatExpiry passed)
    const existingSub = await prisma.subscription.findUnique({
      where: { businessId }
    });

    // Trial is "used" if minutes are exhausted or chat trial has expired
    if (existingSub?.trialMinutesUsed >= 15) {
      return res.status(400).json({ error: 'Trial already used' });
    }

    const now = new Date();
    const trialChatExpiry = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000); // 7 days

    // Create or update subscription to TRIAL
    const subscription = await prisma.subscription.upsert({
      where: { businessId },
      create: {
        businessId,
        plan: 'TRIAL',
        status: 'ACTIVE',
        trialMinutesUsed: 0,
        trialChatExpiry,
        currentPeriodStart: now,
        currentPeriodEnd: trialChatExpiry
      },
      update: {
        plan: 'TRIAL',
        status: 'ACTIVE',
        trialMinutesUsed: 0,
        trialChatExpiry,
        currentPeriodStart: now,
        currentPeriodEnd: trialChatExpiry
      }
    });

    console.log(`âœ… Trial started for business ${businessId}`);

    res.json({
      success: true,
      subscription: {
        plan: 'TRIAL',
        trialMinutes: 15,
        trialChatExpiry,
        status: 'active'
      }
    });
  } catch (error) {
    console.error('Start trial error:', error);
    res.status(500).json({ error: 'Failed to start trial' });
  }
});

// POST /api/subscription/switch-to-payg - Switch to PAYG plan
// If user has active paid subscription, schedule downgrade at period end
router.post('/switch-to-payg', verifyBusinessAccess, async (req, res) => {
  try {
    const { businessId } = req.user;
    const { force } = req.body; // force=true for immediate switch (admin only or free plans)

    // Get current subscription
    const currentSubscription = await prisma.subscription.findUnique({
      where: { businessId }
    });

    // Plans that can switch immediately (no billing period)
    const immediateSwitchPlans = ['FREE', 'TRIAL', 'PAYG', null, undefined];

    // Enterprise with pending payment CAN switch immediately (haven't paid yet)
    // Enterprise with paid status should wait for period end
    const isEnterprisePendingPayment = currentSubscription?.plan === 'ENTERPRISE' &&
      currentSubscription?.enterprisePaymentStatus === 'pending';

    const canSwitchImmediately = !currentSubscription ||
      immediateSwitchPlans.includes(currentSubscription.plan) ||
      currentSubscription.status !== 'ACTIVE' ||
      isEnterprisePendingPayment || // Enterprise pending payment = can switch immediately
      force;

    if (canSwitchImmediately) {
      // Immediate switch - no active paid subscription
      const subscription = await prisma.subscription.upsert({
        where: { businessId },
        create: {
          businessId,
          plan: 'PAYG',
          status: 'ACTIVE',
          balance: 0
        },
        update: {
          plan: 'PAYG',
          status: 'ACTIVE',
          cancelAtPeriodEnd: false,
          scheduledPlanId: null,
          stripeSubscriptionId: null,
          iyzicoSubscriptionId: null
        }
      });

      console.log(`âœ… Switched to PAYG for business ${businessId} (immediate)`);

      return res.json({
        success: true,
        subscription: {
          plan: 'PAYG',
          balance: subscription.balance || 0,
          status: 'active'
        },
        message: 'Switched to PAYG. Please top up your balance to start using.'
      });
    }

    // User has active paid subscription - schedule downgrade at period end
    const periodEnd = currentSubscription.currentPeriodEnd ||
      currentSubscription.enterpriseEndDate ||
      new Date(Date.now() + 30 * 24 * 60 * 60 * 1000); // Default 30 days if no period end

    // Cancel Stripe subscription if exists
    if (currentSubscription.stripeSubscriptionId) {
      try {
        await stripe.subscriptions.update(currentSubscription.stripeSubscriptionId, {
          cancel_at_period_end: true
        });
        console.log(`ðŸ“… Scheduled Stripe cancellation for subscription ${currentSubscription.stripeSubscriptionId}`);
      } catch (stripeError) {
        console.error('Stripe cancellation error:', stripeError.message);
      }
    }

    // Update subscription to schedule PAYG switch at period end
    const subscription = await prisma.subscription.update({
      where: { businessId },
      data: {
        cancelAtPeriodEnd: true,
        scheduledPlanId: 'PAYG'
      }
    });

    console.log(`â° Scheduled PAYG switch for business ${businessId}: ${currentSubscription.plan} â†’ PAYG (at ${periodEnd})`);

    res.json({
      success: true,
      scheduled: true,
      subscription: {
        plan: currentSubscription.plan,
        scheduledPlan: 'PAYG',
        periodEnd: periodEnd,
        status: 'active'
      },
      message: `Plan will be changed to PAYG at the end of current billing period (${new Date(periodEnd).toLocaleDateString('tr-TR')}). You can continue using your current plan until then.`
    });
  } catch (error) {
    console.error('Switch to PAYG error:', error);
    res.status(500).json({ error: 'Failed to switch to PAYG' });
  }
});

// GET /api/subscription/can-make-call - Check if user can make a call
router.get('/can-make-call', verifyBusinessAccess, async (req, res) => {
  try {
    const { businessId } = req.user;

    const subscription = await prisma.subscription.findUnique({
      where: { businessId }
    });

    if (!subscription) {
      return res.json({
        canMakeCall: false,
        reason: 'No subscription found'
      });
    }

    const plan = subscription.plan;

    // TRIAL plan check
    if (plan === 'TRIAL') {
      const minutesUsed = subscription.trialMinutesUsed || 0;
      if (minutesUsed >= 15) {
        return res.json({
          canMakeCall: false,
          reason: 'Trial minutes exhausted',
          trialExpired: true
        });
      }
      return res.json({
        canMakeCall: true,
        minutesRemaining: 15 - minutesUsed,
        chargeType: 'TRIAL'
      });
    }

    // PAYG plan check
    if (plan === 'PAYG') {
      const balance = subscription.balance || 0;
      const pricePerMinute = 23; // TL
      if (balance < pricePerMinute) {
        return res.json({
          canMakeCall: false,
          reason: 'Insufficient balance',
          balance,
          minRequired: pricePerMinute
        });
      }
      return res.json({
        canMakeCall: true,
        balance,
        minutesAvailable: Math.floor(balance / pricePerMinute),
        chargeType: 'BALANCE'
      });
    }

    // STARTER/PRO/ENTERPRISE - check included minutes and balance
    const includedUsed = subscription.includedMinutesUsed || 0;
    const includedLimit = plan === 'STARTER' ? 150 : plan === 'PRO' ? 500 : 1000;
    const balance = subscription.balance || 0;
    const overageRate = plan === 'STARTER' ? 19 : plan === 'PRO' ? 16 : 13;

    if (includedUsed < includedLimit) {
      return res.json({
        canMakeCall: true,
        minutesRemaining: includedLimit - includedUsed,
        chargeType: 'INCLUDED'
      });
    }

    // Included exhausted, check balance for overage
    if (balance >= overageRate) {
      return res.json({
        canMakeCall: true,
        balance,
        chargeType: 'OVERAGE',
        overageRate
      });
    }

    return res.json({
      canMakeCall: false,
      reason: 'Included minutes exhausted and insufficient balance for overage',
      includedUsed,
      includedLimit,
      balance,
      overageRate
    });
  } catch (error) {
    console.error('Can make call check error:', error);
    res.status(500).json({ error: 'Failed to check call eligibility' });
  }
});

export default router;
