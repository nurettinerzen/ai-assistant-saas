/**
 * WhatsApp Webhook Handler
 * Multi-tenant WhatsApp Business API integration
 * Using Google Gemini API
 */

import express from 'express';
import crypto from 'crypto';
import axios from 'axios';
import { PrismaClient } from '@prisma/client';
import { decrypt } from '../utils/encryption.js';
import { webhookRateLimiter } from '../middleware/rateLimiter.js';
import { getDateTimeContext } from '../utils/dateTime.js';
import { logWebhookSignatureFailure } from '../middleware/securityEventLogger.js';
import { buildAssistantPrompt, getActiveTools as getPromptBuilderTools } from '../services/promptBuilder.js';
import { isFreePlanExpired } from '../middleware/checkPlanExpiry.js';
import { calculateTokenCost, hasFreeChat } from '../config/plans.js';
import { getActiveTools, executeTool } from '../tools/index.js';
import callAnalysis from '../services/callAnalysis.js';
import { routeIntent } from '../services/intent-router.js';
import { validateActionClaim } from '../services/action-claim-validator.js';
import { routeMessage, handleDispute } from '../services/message-router.js';
import { isFeatureEnabled } from '../config/feature-flags.js';
import { getToolFailResponse, validateResponseAfterToolFail, executeToolWithRetry } from '../services/tool-fail-handler.js';
import { getGatedTools, canExecuteTool } from '../services/tool-gating.js';
import { logClassification, logRoutingDecision, logViolation, logToolExecution } from '../services/routing-metrics.js';
import { sendWhatsAppMessage as sendWhatsAppMessageCentral } from '../services/whatsapp-sender.js';

// CORE: Channel-agnostic orchestrator
import { handleIncomingMessage } from '../core/handleIncomingMessage.js';
import { getOrCreateSession as getUniversalSession } from '../services/session-mapper.js';
import {
  getOrCreateSession,
  addMessage,
  getHistory,
  getFullHistory,
  getPendingVerification,
  setVerificationRequest,
  clearVerificationRequest,
  terminateSession,
  isSessionActive,
  getTerminationMessage
} from '../services/conversation-manager.js';
import {
  getGeminiClient,
  convertToolsToGeminiFunctions,
  getGeminiModel,
  buildGeminiChatHistory,
  extractTokenUsage
} from '../services/gemini-utils.js';
import { isSessionLocked, getLockMessage, shouldSendAndMarkLockMessage, lockSession } from '../services/session-lock.js';
import { detectUserRisks, getPIIWarningMessages } from '../services/user-risk-detector.js';
import { getState, updateState } from '../services/state-manager.js';

const router = express.Router();
const prisma = new PrismaClient();

// In-memory conversation history
// Format: Map<conversationKey, Array<message>>
const conversations = new Map();

// In-memory set to track processed message IDs (prevents duplicates from Meta retries)
// Messages are kept for 5 minutes then cleaned up
const processedMessages = new Map();
const MESSAGE_DEDUP_TTL = 5 * 60 * 1000; // 5 minutes

// Cleanup old processed messages every minute
setInterval(() => {
  const now = Date.now();
  for (const [messageId, timestamp] of processedMessages) {
    if (now - timestamp > MESSAGE_DEDUP_TTL) {
      processedMessages.delete(messageId);
    }
  }
}, 60 * 1000);

// ============================================================================
// WEBHOOK ENDPOINTS
// ============================================================================

// Webhook verification (Meta's initial setup verification)
router.get('/webhook', webhookRateLimiter.middleware(), async (req, res) => {
  const mode = req.query['hub.mode'];
  const token = req.query['hub.verify_token'];
  const challenge = req.query['hub.challenge'];

  if (mode && token) {
    if (mode === 'subscribe') {
      const business = await prisma.business.findFirst({
        where: { whatsappVerifyToken: token }
      });

      if (business) {
        console.log(`‚úÖ Webhook verified for business: ${business.name} (ID: ${business.id})`);
        res.status(200).send(challenge);
      } else {
        console.log('‚ùå Webhook verification failed: Invalid verify token');
        res.sendStatus(403);
      }
    } else {
      res.sendStatus(403);
    }
  } else {
    res.sendStatus(400);
  }
});

/**
 * Verify WhatsApp webhook signature (Meta/Facebook)
 * Uses X-Hub-Signature-256 header with HMAC-SHA256
 */
function verifyWhatsAppSignature(req, appSecret) {
  if (!appSecret) {
    console.warn('‚ö†Ô∏è WHATSAPP_APP_SECRET not configured - signature verification disabled');
    return true; // Allow in development, but log warning
  }

  const signature = req.headers['x-hub-signature-256'];
  if (!signature) {
    console.error('‚ùå Missing X-Hub-Signature-256 header');
    return false;
  }

  // Meta sends signature as "sha256=<hash>"
  const signatureHash = signature.split('=')[1];
  if (!signatureHash) {
    console.error('‚ùå Invalid signature format');
    return false;
  }

  // Calculate expected signature
  const expectedHash = crypto
    .createHmac('sha256', appSecret)
    .update(JSON.stringify(req.body))
    .digest('hex');

  // Constant-time comparison to prevent timing attacks
  try {
    return crypto.timingSafeEqual(
      Buffer.from(signatureHash, 'hex'),
      Buffer.from(expectedHash, 'hex')
    );
  } catch (e) {
    console.error('‚ùå Signature verification failed:', e.message);
    return false;
  }
}

// Webhook - Incoming messages (Multi-tenant)
router.post('/webhook', webhookRateLimiter.middleware(), async (req, res) => {
  console.log('üîî WhatsApp WEBHOOK RECEIVED:', JSON.stringify(req.body, null, 2));

  // SECURITY: Verify webhook signature
  const appSecret = process.env.WHATSAPP_APP_SECRET || process.env.META_APP_SECRET;
  if (!verifyWhatsAppSignature(req, appSecret)) {
    console.error('‚ùå WhatsApp webhook signature verification failed');

    // Log security event
    await logWebhookSignatureFailure(req, 'whatsapp', 401);

    return res.sendStatus(401);
  }

  try {
    const body = req.body;

    // Validate webhook payload from Meta
    if (body.object === 'whatsapp_business_account') {
      const entry = body.entry?.[0];
      const changes = entry?.changes?.[0];
      const value = changes?.value;

      // Get the phone number ID to identify which business this message is for
      const phoneNumberId = value?.metadata?.phone_number_id;

      if (!phoneNumberId) {
        console.error('‚ùå No phone number ID in webhook payload');
        return res.sendStatus(400);
      }

      // Find the business by phone number ID (include integrations for tools)
      let business = await prisma.business.findFirst({
        where: { whatsappPhoneNumberId: phoneNumberId },
        include: {
          assistants: {
            where: { isActive: true },
            orderBy: { createdAt: 'desc' },
            take: 1
          },
          integrations: {
            where: { isActive: true }
          }
        }
      });

      // Fallback: If no business found but phoneNumberId matches env, use env credentials
      // This is for testing/development with the default test account
      if (!business && phoneNumberId === process.env.WHATSAPP_PHONE_NUMBER_ID) {
        console.log('‚ö†Ô∏è Using env fallback for WhatsApp - phone number ID matched env');

        // First try to find the dev account (business ID 21)
        business = await prisma.business.findUnique({
          where: { id: 21 },
          include: {
            assistants: {
              where: { isActive: true },
              orderBy: { createdAt: 'desc' },
              take: 1
            },
            integrations: {
              where: { isActive: true }
            }
          }
        });

        // If dev account not found, fall back to first business with active assistant
        if (!business) {
          business = await prisma.business.findFirst({
            where: {
              assistants: { some: { isActive: true } }
            },
            include: {
              assistants: {
                where: { isActive: true },
                orderBy: { createdAt: 'desc' },
                take: 1
              },
              integrations: {
                where: { isActive: true }
              }
            }
          });
        }

        if (business) {
          // Inject env credentials for this request
          business._useEnvCredentials = true;
        }
      }

      if (!business) {
        console.error(`‚ùå No business found for phone number ID: ${phoneNumberId}`);
        return res.sendStatus(404);
      }

      console.log(`‚úÖ Message for business: ${business.name} (ID: ${business.id})`);

      // Check subscription and plan expiry
      const subscription = await prisma.subscription.findUnique({
        where: { businessId: business.id },
        include: { business: true }
      });

      if (subscription && isFreePlanExpired(subscription)) {
        console.log(`üö´ WhatsApp blocked - FREE plan expired for business ${business.id}`);
        // Silently ignore the message - don't respond
        return res.sendStatus(200);
      }

      // Process incoming messages
      if (value?.messages && value.messages.length > 0) {
        const message = value.messages[0];
        const from = message.from; // Sender's phone number
        const messageBody = message.text?.body; // Message content
        const messageId = message.id;

        // Skip if not a text message
        if (!messageBody) {
          console.log('‚ö†Ô∏è Non-text message received, skipping');
          return res.sendStatus(200);
        }

        // IMPORTANT: Check for duplicate messages (Meta may retry)
        if (processedMessages.has(messageId)) {
          console.log(`‚ö†Ô∏è Duplicate message detected, skipping: ${messageId}`);
          return res.sendStatus(200);
        }

        // Mark message as being processed IMMEDIATELY
        processedMessages.set(messageId, Date.now());

        console.log('üì© WhatsApp message received:', {
          businessId: business.id,
          businessName: business.name,
          from,
          message: messageBody,
          id: messageId
        });

        // IMPORTANT: Respond to Meta immediately to prevent retries
        // Then process the message asynchronously
        res.sendStatus(200);

        // Process message asynchronously (don't await)
        processWhatsAppMessage(business, from, messageBody, messageId).catch(err => {
          console.error('‚ùå Async message processing error:', err);
        });

        return; // Already sent response
      }

      res.sendStatus(200);
    } else {
      res.sendStatus(404);
    }
  } catch (error) {
    console.error('‚ùå Webhook error:', error);
    res.sendStatus(500);
  }
});

// ============================================================================
// ASYNC MESSAGE PROCESSING
// ============================================================================

/**
 * Process WhatsApp message asynchronously
 * Called after webhook returns 200 to Meta
 */
async function processWhatsAppMessage(business, from, messageBody, messageId) {
  try {
    // ===== ROUTE-LEVEL GUARD: CHECK SESSION LOCK =====
    // Get universal session ID for this user
    const sessionId = await getUniversalSession(business.id, 'WHATSAPP', from);
    const language = business?.language || 'TR';

    // GUARD 1: Check if session is locked
    const lockStatus = await isSessionLocked(sessionId);
    if (lockStatus.locked) {
      console.log(`üîí [WhatsApp Guard] Session ${sessionId} is LOCKED (${lockStatus.reason})`);

      // Check spam prevention - only send lock message once per minute
      const shouldSend = await shouldSendAndMarkLockMessage(sessionId);
      if (shouldSend) {
        const lockMsg = getLockMessage(lockStatus.reason, language);
        await sendWhatsAppMessage(business, from, lockMsg, { inboundMessageId: messageId });
        console.log(`üîí [WhatsApp Guard] Lock message sent`);
      } else {
        console.log(`üîí [WhatsApp Guard] Lock message skipped (spam prevention)`);
      }

      return; // EXIT - Do not process message
    }

    // GUARD 2: Detect user input risks (abuse, threats, spam, PII)
    const state = await getState(sessionId);
    const riskDetection = detectUserRisks(messageBody, language, state);

    // Persist state if abuse counter was updated
    if (riskDetection.warnings.some(w => w.type === 'PROFANITY')) {
      await updateState(sessionId, state);
      console.log(`[WhatsApp Guard] State updated - abuse counter: ${state.abuseCounter}`);
    }

    // If critical risk detected ‚Üí lock session immediately
    if (riskDetection.shouldLock) {
      console.log(`üö® [WhatsApp Guard] RISK DETECTED: ${riskDetection.reason}`);

      // Lock the session
      await lockSession(sessionId, riskDetection.reason);

      // Send lock message to user
      const lockMsg = getLockMessage(riskDetection.reason, language);
      await sendWhatsAppMessage(business, from, lockMsg, { inboundMessageId: messageId });

      return; // EXIT - Do not process message
    }

    // SOFT REFUSAL: Encoded injection or other soft-block cases
    // Session stays open but this specific message is rejected
    if (riskDetection.softRefusal) {
      console.log(`üõ°Ô∏è [WhatsApp Guard] SOFT REFUSAL - message rejected, session stays open`);
      await sendWhatsAppMessage(business, from, riskDetection.refusalMessage, { inboundMessageId: messageId });
      return; // EXIT - Don't process but don't lock
    }

    // If PII warnings (but not locked yet), prepend warning to response
    const piiWarnings = getPIIWarningMessages(riskDetection.warnings);
    const hasPIIWarnings = piiWarnings.length > 0;

    // ===== SESSION OK - DELEGATE TO CORE ORCHESTRATOR =====

    console.log('\nüì± [WhatsApp Adapter] Delegating to core orchestrator...');

    // Call core orchestrator (unified pipeline for all channels)
    const result = await handleIncomingMessage({
      channel: 'WHATSAPP',
      business,
      assistant: business.assistants?.[0],
      channelUserId: from,
      sessionId, // CRITICAL: Pass sessionId to prevent new session creation
      messageId,
      userMessage: messageBody,
      language: business.language || 'TR',
      timezone: business.timezone || 'Europe/Istanbul',
      metadata: {
        inboundMessageId: messageId
      }
    });

    // Prepare final response (with PII warnings if any)
    let aiResponse = result.reply;
    if (hasPIIWarnings) {
      const warningText = piiWarnings.join('\n');
      aiResponse = `${warningText}\n\n${aiResponse}`;
    }

    // Send response using business's credentials (with idempotency)
    await sendWhatsAppMessage(business, from, aiResponse, { inboundMessageId: messageId });
  } catch (error) {
    console.error('‚ùå Error processing WhatsApp message:', error);

    // Persist to ErrorLog
    import('../services/errorLogger.js')
      .then(({ logChatError }) => {
        logChatError(error, {
          source: 'whatsapp',
          businessId: business?.id,
          sessionId: from || null,
        }).catch(() => {});
      })
      .catch(() => {});

    // Try to send error message to user (no idempotency for error messages)
    try {
      await sendWhatsAppMessage(
        business,
        from,
        '√úzg√ºn√ºm, ≈üu anda bir sorun ya≈üƒ±yorum. L√ºtfen daha sonra tekrar deneyin.'
      );
    } catch (sendError) {
      console.error('‚ùå Failed to send error message:', sendError);
    }
  }
}

// ============================================================================
// AI RESPONSE WITH GEMINI
// ============================================================================

/**
 * Generate AI response using Gemini with proper function calling
 * Same architecture as chat.js - model calls tools when needed
 */
/**
 * @deprecated This function is deprecated. WhatsApp now uses the unified orchestrator (handleIncomingMessage).
 * Kept for reference during migration. Will be removed after validation.
 */
async function generateAIResponse_DEPRECATED(business, phoneNumber, messageBody, context = {}) {
  try {
    console.log('\nüì± [WhatsApp] Delegating to core orchestrator...');

    const assistant = business.assistants?.[0];
    const language = business?.language || 'TR';
    const subscription = context.subscription;

    // Conversation key for in-memory cache
    const conversationKey = `${business.id}:${phoneNumber}`;

    // Get universal session ID
    const sessionId = await getUniversalSession(business.id, 'WHATSAPP', phoneNumber);

    // Build system prompt
    const systemPrompt = await buildSystemPrompt(business, assistant);

    // Session timeout: 30 minutes of inactivity = new session
    const SESSION_TIMEOUT_MS = 30 * 60 * 1000; // 30 minutes

    // Get conversation history (from memory cache or database)
    let history;
    let existingLog;

    // Check if existing session has timed out
    existingLog = await prisma.chatLog.findUnique({
      where: { sessionId },
      select: { id: true, inputTokens: true, outputTokens: true, totalCost: true, updatedAt: true, status: true, messages: true }
    });

    if (existingLog) {
      const lastActivity = new Date(existingLog.updatedAt);
      const timeSinceActivity = Date.now() - lastActivity.getTime();

      if (timeSinceActivity > SESSION_TIMEOUT_MS) {
        // Session timed out (30 min inactivity) - archive old session and start fresh
        console.log(`‚è∞ [WhatsApp] Session for ${phoneNumber} timed out (${Math.round(timeSinceActivity / 60000)} min) - starting new session`);

        // Determine normalized topic for timed out session
        let normalizedCategory = null;
        let normalizedTopic = null;
        if (existingLog.messages && Array.isArray(existingLog.messages) && existingLog.messages.length > 0) {
          try {
            const transcriptText = callAnalysis.formatChatMessagesAsTranscript(existingLog.messages);
            if (transcriptText && transcriptText.length > 20) {
              const topicResult = await callAnalysis.determineNormalizedTopic(transcriptText);
              normalizedCategory = topicResult.normalizedCategory;
              normalizedTopic = topicResult.normalizedTopic;
              console.log(`üìä [WhatsApp] Timed out session topic: ${normalizedCategory} > ${normalizedTopic}`);
            }
          } catch (topicError) {
            console.error('‚ö†Ô∏è [WhatsApp] Topic determination failed:', topicError.message);
          }
        }

        // Archive old session with timestamp suffix
        const archivedSessionId = `${sessionId}-${existingLog.updatedAt.getTime()}`;
        await prisma.chatLog.update({
          where: { sessionId },
          data: {
            sessionId: archivedSessionId,
            status: 'ended',
            normalizedCategory: normalizedCategory,
            normalizedTopic: normalizedTopic,
            updatedAt: new Date()
          }
        });
        console.log(`üì¶ [WhatsApp] Archived old session as: ${archivedSessionId}`);

        // Start fresh with same base session ID (will be created on save)
        history = [];
        existingLog = null;
        conversations.delete(conversationKey);
      } else if (conversations.has(conversationKey)) {
        // Use cached history (session still active)
        history = conversations.get(conversationKey);
        console.log(`‚úÖ [WhatsApp] Session active (${Math.round(timeSinceActivity / 60000)} min since last activity)`);
      } else if (existingLog.messages && Array.isArray(existingLog.messages)) {
        // Load history from database (last 40 messages)
        history = existingLog.messages.slice(-40);
        conversations.set(conversationKey, history);
        console.log(`üìö [WhatsApp] Loaded ${history.length} messages from database for ${phoneNumber}`);
      } else {
        history = [];
        conversations.set(conversationKey, history);
      }
    } else {
      history = [];
      conversations.set(conversationKey, history);
    }

    // ============================================
    // INTENT ROUTING (NEW!)
    // ============================================
    console.log('üéØ [WhatsApp] Starting intent detection for:', sessionId);

    // Check if session is still active - if terminated, reject message
    const session = getOrCreateSession(sessionId, 'whatsapp');

    if (!session.isActive) {
      console.log('üõë [WhatsApp] Session terminated - rejecting message');

      const terminationMessage = getTerminationMessage(session.terminationReason || 'off_topic', business.language);

      // Send termination message (with idempotency)
      await sendWhatsAppMessage(business, phoneNumber, terminationMessage, { inboundMessageId: context.messageId });

      // Don't process further
      return;
    }

    // Detect user intent and get appropriate tools
    const intentResult = await routeIntent(messageBody, sessionId, business.language, { name: business.name });

    console.log('üéØ [WhatsApp] Intent result:', {
      intent: intentResult.intent,
      tools: intentResult.tools,
      shouldTerminate: intentResult.shouldTerminate
    });

    // Handle session termination
    if (intentResult.shouldTerminate) {
      terminateSession(sessionId, intentResult.intent === 'off_topic' ? 'off_topic' : 'verification_failed');

      // Send termination message (with idempotency)
      await sendWhatsAppMessage(business, phoneNumber, intentResult.response, { inboundMessageId: context.messageId });

      // Save to conversation history
      history.push({ role: 'assistant', content: intentResult.response });

      // Save conversation to database
      await prisma.whatsappConversation.upsert({
        where: { id: conversationKey },
        update: {
          messages: JSON.stringify(history),
          lastMessageAt: new Date()
        },
        create: {
          id: conversationKey,
          businessId: business.id,
          phoneNumber,
          messages: JSON.stringify(history),
          lastMessageAt: new Date()
        }
      });

      return;
    }

    // Handle direct responses (no tools needed)
    if (intentResult.response) {
      await sendWhatsAppMessage(business, phoneNumber, intentResult.response, { inboundMessageId: context.messageId });

      // Save to conversation history
      history.push({ role: 'assistant', content: intentResult.response });

      // Save conversation to database
      await prisma.whatsappConversation.upsert({
        where: { id: conversationKey },
        update: {
          messages: JSON.stringify(history),
          lastMessageAt: new Date()
        },
        create: {
          id: conversationKey,
          businessId: business.id,
          phoneNumber,
          messages: JSON.stringify(history),
          lastMessageAt: new Date()
        }
      });

      return;
    }

    // ============================================
    // HANDLE VERIFICATION RESPONSE (SPECIAL CASE)
    // ============================================
    // When user is responding to a verification request, call tool directly
    let verificationToolResult = null;
    if (intentResult.intent === 'verification_response' && intentResult.verificationData) {
      console.log('üîê [WhatsApp] Processing verification response with tool');

      const pendingVerification = getPendingVerification(sessionId);

      if (pendingVerification) {
        // Call customer_data_lookup with the cached data + user's provided verification data
        // Merge all verification data from current response
        const toolResult = await executeTool(
          'customer_data_lookup',
          {
            query_type: intentResult.queryType || pendingVerification.queryType || 'siparis',
            // Spread all verification data (order_number, phone, vkn, tc, customer_name, etc.)
            ...intentResult.verificationData
          },
          business,
          {
            sessionId,
            intent: intentResult.intent,
            requiresVerification: true,
            channel: 'WHATSAPP',
            from: phoneNumber
          }
        );

        // Check if verification failed and should terminate
        if (toolResult.shouldTerminate) {
          terminateSession(sessionId, 'verification_failed');
          await sendWhatsAppMessage(business, phoneNumber, toolResult.error || getTerminationMessage('verification_failed', business.language), { inboundMessageId: context.messageId });

          history.push({ role: 'assistant', content: toolResult.error || getTerminationMessage('verification_failed', business.language) });

          await prisma.whatsappConversation.upsert({
            where: { id: conversationKey },
            update: { messages: JSON.stringify(history), lastMessageAt: new Date() },
            create: { id: conversationKey, businessId: business.id, phoneNumber, messages: JSON.stringify(history), lastMessageAt: new Date() }
          });

          return;
        }

        // Store tool result to pass to Gemini
        verificationToolResult = toolResult;
        console.log('‚úÖ [WhatsApp] Verification tool result received, will pass to Gemini for formatting');
      }
    }

    // ============================================
    // HANDLE COMPLAINT (PRE-EMPTIVE CALLBACK)
    // ============================================
    // When user intent is complaint, automatically create callback
    if (intentResult.intent === 'complaint') {
      console.log('üìû [WhatsApp] Complaint detected, creating callback pre-emptively');

      // Clear any pending verification (user gave up on providing info)
      if (getPendingVerification(sessionId)) {
        clearVerificationRequest(sessionId);
        console.log('üßπ [WhatsApp] Cleared pending verification - user switched to complaint');
      }

      const {
        extractCustomerInfoFromHistory,
        extractTopicFromHistory,
        buildCallbackContextMessage
      } = await import('../services/callback-helper.js');

      // Extract customer info from history (WhatsApp has phone number available)
      const customerInfo = extractCustomerInfoFromHistory(history, { phone: phoneNumber, customerName: null });
      const topic = extractTopicFromHistory(history);

      // Call create_callback tool
      const callbackResult = await executeTool(
        'create_callback',
        {
          customer_name: customerInfo.name,
          customer_phone: customerInfo.phone,
          topic: topic,
          priority: 'HIGH' // Complaints are always high priority
        },
        business,
        {
          sessionId,
          intent: 'complaint',
          channel: 'WHATSAPP',
          from: phoneNumber
        }
      );

      if (callbackResult.success) {
        // Store tool result to pass to Gemini
        verificationToolResult = {
          success: true,
          data: callbackResult.data,
          message: buildCallbackContextMessage(callbackResult.data, business.language || 'TR')
        };
        console.log('‚úÖ [WhatsApp] Callback created, will pass to Gemini for formatting');
      }
    }

    // Filter tools based on intent
    // IMPORTANT: If we have verificationToolResult, we DON'T want Gemini to call tools
    // We already called the tool pre-emptively, just need Gemini to format the response
    const allTools = getActiveTools(business);
    const filteredTools = verificationToolResult
      ? [] // No tools when we have pre-emptive verification result
      : (intentResult.tools.length > 0
          ? allTools.filter(tool => intentResult.tools.includes(tool.function.name))
          : []); // No tools for greeting, company_info, etc.

    console.log('üîß [WhatsApp] Tools available:', filteredTools.map(t => t.function.name));

    // Get Gemini model with tools
    const model = getGeminiModel({
      model: 'gemini-2.5-flash',
      temperature: 0.7,
      maxOutputTokens: 1500,
      tools: filteredTools.length > 0 ? filteredTools : null
    });

    // Build chat history for Gemini (don't exclude last message, we'll add it separately)
    const chatHistory = buildGeminiChatHistory(systemPrompt, history, false);

    // Start chat with history
    const chat = model.startChat({ history: chatHistory });

    // Token tracking
    let totalInputTokens = 0;
    let totalOutputTokens = 0;

    // Add user message to history (before sending to Gemini)
    history.push({
      role: 'user',
      content: messageBody
    });

    // Send user message to Gemini
    let result;
    let response;

    if (verificationToolResult) {
      console.log('üíâ [WhatsApp] Including verification tool result in message for Gemini to interpret');

      // Pass the STRUCTURED DATA to Gemini for interpretation
      let contextMessage;

      if (verificationToolResult.verificationPending) {
        // Verification is pending - tool is asking for more info
        contextMessage = `Doƒürulama gerekli. Sistem mesajƒ±: ${verificationToolResult.message}`;
      } else if (verificationToolResult.success) {
        // Verification successful - return data
        contextMessage = `Doƒürulama ba≈üarƒ±lƒ±! M√º≈üteri bilgileri: ${JSON.stringify(verificationToolResult.data)}`;
      } else {
        // Verification failed
        contextMessage = `Doƒürulama ba≈üarƒ±sƒ±z. Structured data: ${JSON.stringify({
          validation: verificationToolResult.validation,
          context: verificationToolResult.context,
          verificationFailed: verificationToolResult.verificationFailed
        })}`;
      }

      const messageWithContext = `Kullanƒ±cƒ± mesajƒ±: "${messageBody}"\n\nTool sonucu (bunu YORUMLA ve doƒüal yanƒ±t √ºret):\n${contextMessage}`;

      result = await chat.sendMessage(messageWithContext);
      response = result.response;
    } else {
      // Normal flow: Send user message to Gemini - it will call tools when needed
      result = await chat.sendMessage(messageBody);
      response = result.response;
    }

    // Track tokens from first response
    const tokens = extractTokenUsage(response);
    totalInputTokens += tokens.inputTokens;
    totalOutputTokens += tokens.outputTokens;

    // Handle function calls (up to 3 iterations)
    let iterations = 0;
    const maxIterations = 3;

    while (iterations < maxIterations) {
      const functionCalls = response.functionCalls();

      if (!functionCalls || functionCalls.length === 0) {
        break; // No more function calls
      }

      console.log('üîß [WhatsApp] Gemini function call:', functionCalls[0].name, functionCalls[0].args);

      // Execute the function
      const functionCall = functionCalls[0];
      const toolResult = await executeTool(functionCall.name, functionCall.args, business, {
        channel: 'WHATSAPP',
        sessionId: sessionId,
        conversationId: sessionId,
        callerPhone: phoneNumber, // WhatsApp phone number for verification
        phone: phoneNumber,
        from: phoneNumber
      });

      console.log('üîß [WhatsApp] Tool result:', toolResult.success ? 'SUCCESS' : 'FAILED', toolResult.message?.substring(0, 100));

      // Send function response back to Gemini
      result = await chat.sendMessage([
        {
          functionResponse: {
            name: functionCall.name,
            response: {
              success: toolResult.success,
              data: toolResult.data || null,
              message: toolResult.message || toolResult.error || 'Tool executed',
              validation: toolResult.validation || null,
              context: toolResult.context || null,
              verificationFailed: toolResult.verificationFailed || false,
              notFound: toolResult.notFound || false
            }
          }
        }
      ]);
      response = result.response;

      // Track tokens from function call response
      if (response.usageMetadata) {
        totalInputTokens += response.usageMetadata.promptTokenCount || 0;
        totalOutputTokens += response.usageMetadata.candidatesTokenCount || 0;
      }

      iterations++;
    }

    let text = '';
    try {
      text = response.text() || '';
    } catch (e) {
      console.log('‚ö†Ô∏è [WhatsApp] Could not get text from response');
    }

    console.log('üìù [WhatsApp] Final response text:', text?.substring(0, 100));
    console.log(`üìä [WhatsApp] Token usage - Input: ${totalInputTokens}, Output: ${totalOutputTokens}`);

    // Check if any function calls were made during the conversation
    const hadFunctionCall = iterations > 0;

    // ============================================
    // ACTION CLAIM VALIDATION (ENFORCEMENT)
    // ============================================
    // Prevent AI from claiming actions without backing them with tool calls
    const actionValidation = validateActionClaim(text, hadFunctionCall, language);

    if (!actionValidation.valid) {
      console.warn('‚ö†Ô∏è [WhatsApp] ACTION CLAIM VIOLATION:', actionValidation.error);
      console.log('üîß [WhatsApp] Forcing AI to correct response...');

      // Send correction prompt to Gemini
      try {
        const correctionResult = await chat.sendMessage(actionValidation.correctionPrompt);
        const correctedText = correctionResult.response.text();

        // Track tokens from correction
        if (correctionResult.response.usageMetadata) {
          totalInputTokens += correctionResult.response.usageMetadata.promptTokenCount || 0;
          totalOutputTokens += correctionResult.response.usageMetadata.candidatesTokenCount || 0;
        }

        // Use corrected text
        text = correctedText;
        console.log('‚úÖ [WhatsApp] Response corrected:', correctedText.substring(0, 100));
      } catch (correctionError) {
        console.error('‚ùå [WhatsApp] Correction failed:', correctionError.message);
        // Fallback: strip action claims
        text = language === 'TR'
          ? '√úzg√ºn√ºm, bu konuda m√º≈üteri hizmetlerimize ba≈üvurmanƒ±z gerekiyor.'
          : 'I apologize, for this you need to contact our customer service.';
      }
    }

    const finalResponse = text || (language === 'TR'
      ? '√úzg√ºn√ºm, bir yanƒ±t olu≈üturamadƒ±m.'
      : 'Sorry, I could not generate a response.');

    // Add AI response to history
    history.push({
      role: 'assistant',
      content: finalResponse
    });

    // Limit history size
    if (history.length > 40) {
      conversations.set(conversationKey, history.slice(-40));
    }

    // Calculate token cost based on plan
    const planName = subscription?.plan || 'FREE';
    const countryCode = business?.country || 'TR';
    const isFree = hasFreeChat(planName);

    let tokenCost = { inputCost: 0, outputCost: 0, totalCost: 0 };
    if (!isFree) {
      tokenCost = calculateTokenCost(totalInputTokens, totalOutputTokens, planName, countryCode);
    }

    console.log(`üí∞ [WhatsApp] Chat cost: ${tokenCost.totalCost.toFixed(6)} TL (Plan: ${planName}, Free: ${isFree})`);

    // Accumulate tokens
    const accumulatedInputTokens = (existingLog?.inputTokens || 0) + totalInputTokens;
    const accumulatedOutputTokens = (existingLog?.outputTokens || 0) + totalOutputTokens;
    const accumulatedCost = (existingLog?.totalCost || 0) + tokenCost.totalCost;

    // Save/Update ChatLog for analytics with token info
    try {
      await prisma.chatLog.upsert({
        where: { sessionId },
        update: {
          messages: history,
          messageCount: history.length,
          inputTokens: accumulatedInputTokens,
          outputTokens: accumulatedOutputTokens,
          totalCost: accumulatedCost,
          updatedAt: new Date()
        },
        create: {
          sessionId,
          businessId: business.id,
          assistantId: assistant?.id || null,
          channel: 'WHATSAPP',
          customerPhone: phoneNumber,
          messages: history,
          messageCount: history.length,
          inputTokens: totalInputTokens,
          outputTokens: totalOutputTokens,
          totalCost: tokenCost.totalCost,
          status: 'active'
        }
      });

      // If not free plan, track usage
      if (!isFree && tokenCost.totalCost > 0 && subscription) {
        // For PAYG: deduct from balance
        await prisma.subscription.update({
          where: { id: subscription.id },
          data: {
            balance: {
              decrement: planName === 'PAYG' ? tokenCost.totalCost : 0
            }
          }
        });

        // Create usage record for tracking
        await prisma.usageRecord.create({
          data: {
            subscriptionId: subscription.id,
            channel: 'WHATSAPP',
            conversationId: sessionId,
            durationSeconds: 0,
            durationMinutes: 0,
            chargeType: planName === 'PAYG' ? 'BALANCE' : 'INCLUDED',
            totalCharge: tokenCost.totalCost,
            assistantId: assistant?.id || null,
            metadata: {
              inputTokens: totalInputTokens,
              outputTokens: totalOutputTokens,
              inputCost: tokenCost.inputCost,
              outputCost: tokenCost.outputCost
            }
          }
        });
      }
    } catch (logError) {
      console.error('‚ö†Ô∏è Failed to save WhatsApp chat log:', logError.message);
    }

    console.log(`ü§ñ [WhatsApp] Gemini Response for ${business.name}:`, finalResponse);
    return finalResponse;

  } catch (error) {
    console.error('‚ùå Error generating AI response:', error);
    return getErrorMessage(business.language);
  }
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Build system prompt for the assistant
 * Uses the central promptBuilder service
 */
async function buildSystemPrompt(business, assistant) {
  const language = business?.language || 'TR';
  const timezone = business?.timezone || 'Europe/Istanbul';

  // Get current date/time for this business's timezone
  const dateTimeContext = getDateTimeContext(timezone, language);

  // Get active tools list for prompt
  const activeToolsList = getPromptBuilderTools(business, business.integrations || []);

  // Use the central prompt builder
  const basePrompt = buildAssistantPrompt(assistant || {}, business, activeToolsList);

  // Get Knowledge Base content for this business
  const knowledgeItems = await prisma.knowledgeBase.findMany({
    where: { businessId: business.id, status: 'ACTIVE' }
  });

  // Build Knowledge Base context
  let knowledgeContext = '';
  if (knowledgeItems && knowledgeItems.length > 0) {
    const kbByType = { URL: [], DOCUMENT: [], FAQ: [] };

    for (const item of knowledgeItems) {
      if (item.type === 'FAQ' && item.question && item.answer) {
        kbByType.FAQ.push(`S: ${item.question}\nC: ${item.answer}`);
      } else if (item.content) {
        kbByType[item.type]?.push(`[${item.title}]: ${item.content.substring(0, 1000)}`);
      }
    }

    if (kbByType.FAQ.length > 0) {
      knowledgeContext += '\n\n## SIK SORULAN SORULAR\n' + kbByType.FAQ.join('\n\n');
    }
    if (kbByType.URL.length > 0) {
      knowledgeContext += '\n\n## WEB SAYFASI ƒ∞√áERƒ∞ƒûƒ∞\n' + kbByType.URL.join('\n\n');
    }
    if (kbByType.DOCUMENT.length > 0) {
      knowledgeContext += '\n\n## D√ñK√úMANLAR\n' + kbByType.DOCUMENT.join('\n\n');
    }

    console.log(`üìö [WhatsApp] Knowledge Base items added: ${knowledgeItems.length}`);
  }

  // Add KB usage instruction if knowledge base exists
  const kbInstruction = knowledgeContext ? (language === 'TR'
    ? `\n\n## Bƒ∞LGƒ∞ BANKASI KULLANIM KURALLARI
A≈üaƒüƒ±daki bilgi bankasƒ± i√ßeriƒüini AKTƒ∞F OLARAK KULLAN:
- Fiyat sorulduƒüunda: KB'de varsa HEMEN S√ñYLE
- √ñzellik sorulduƒüunda: KB'de varsa S√ñYLE
- KB'de bilgi VARSA doƒürudan payla≈ü`
    : `\n\n## KNOWLEDGE BASE USAGE
ACTIVELY USE the knowledge base content below when answering questions.`)
    : '';

  return `${dateTimeContext}

${basePrompt}${kbInstruction}
${knowledgeContext}`;
}

/**
 * Get error message in business language
 */
function getErrorMessage(language) {
  const errorMessages = {
    'EN': 'Sorry, I\'m experiencing an issue right now. Please try again later.',
    'TR': '√úzg√ºn√ºm, ≈üu anda bir sorun ya≈üƒ±yorum. L√ºtfen daha sonra tekrar deneyin.',
    'ES': 'Lo siento, estoy experimentando un problema en este momento. Por favor, int√©ntelo de nuevo m√°s tarde.',
    'FR': 'D√©sol√©, je rencontre un probl√®me en ce moment. Veuillez r√©essayer plus tard.',
    'DE': 'Entschuldigung, ich habe gerade ein Problem. Bitte versuchen Sie es sp√§ter erneut.'
  };
  return errorMessages[language] || errorMessages['EN'];
}

/**
 * Send WhatsApp message using business credentials
 * Now routes through central whatsapp-sender.js with idempotency support
 *
 * @param {Object} business - Business object
 * @param {string} to - Recipient phone number
 * @param {string} text - Message text
 * @param {Object} options - Options
 * @param {string} options.inboundMessageId - Original webhook message ID (for idempotency)
 */
async function sendWhatsAppMessage(business, to, text, options = {}) {
  try {
    const result = await sendWhatsAppMessageCentral(business, to, text, options);

    if (result.duplicate) {
      console.log(`‚ôªÔ∏è [WhatsApp] Duplicate send blocked for business ${business.name}`);
    } else {
      console.log(`‚úÖ WhatsApp message sent for business ${business.name}:`, result.messageId);
    }

    return result;
  } catch (error) {
    console.error('‚ùå Error sending WhatsApp message:', error.message);
    throw error;
  }
}

// ============================================================================
// ADMIN/TEST ENDPOINTS
// ============================================================================

// Manual message sending endpoint (for testing)
router.post('/send', async (req, res) => {
  try {
    const { businessId, to, message } = req.body;

    if (!businessId || !to || !message) {
      return res.status(400).json({ error: 'businessId, to and message required' });
    }

    const business = await prisma.business.findUnique({
      where: { id: parseInt(businessId) }
    });

    if (!business) {
      return res.status(404).json({ error: 'Business not found' });
    }

    const result = await sendWhatsAppMessage(business, to, message);
    res.json({ success: true, data: result });
  } catch (error) {
    // Persist to ErrorLog
    import('../services/errorLogger.js')
      .then(({ logChatError }) => {
        logChatError(error, {
          source: 'whatsapp/send',
          businessId: parseInt(businessId) || null,
          endpoint: req.path,
          method: req.method,
        }).catch(() => {});
      })
      .catch(() => {});

    res.status(500).json({
      error: 'Failed to send message',
      details: error.message
    });
  }
});

// Clear conversation history (admin)
router.delete('/conversations/:businessId/:phoneNumber', (req, res) => {
  const { businessId, phoneNumber } = req.params;
  const conversationKey = `${businessId}:${phoneNumber}`;
  conversations.delete(conversationKey);
  res.json({ success: true, message: 'Conversation history cleared' });
});

// List active conversations (admin)
router.get('/conversations', (req, res) => {
  const activeConversations = Array.from(conversations.keys()).map(key => {
    const [businessId, phoneNumber] = key.split(':');
    return {
      businessId,
      phoneNumber,
      messageCount: conversations.get(key).length
    };
  });
  res.json({ conversations: activeConversations });
});

export default router;
