/**
 * Intent Router Service
 * Detects user intent and maps to appropriate tools
 * Handles session counters for security (off-topic, verification attempts)
 */

import { GoogleGenerativeAI } from '@google/generative-ai';
import { verificationCache } from './verification-manager.js';
import { detectNumberType } from '../utils/text.js';

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

// Intent configuration with tool mapping and security rules
export const INTENT_CONFIG = {
  // ============================================
  // TRANSACTIONAL INTENTS (Verification Required)
  // ============================================
  order_status: {
    tools: ['customer_data_lookup'],
    requiresVerification: true,
    verificationFields: ['order_number'],
    maxAttempts: 3,
    description: 'User asks about ORDER STATUS/DELIVERY: sipari≈ü, sipari≈üim, teslimat, ne zaman gelir. NOT debts or cargo tracking codes.'
  },

  debt_inquiry: {
    tools: ['customer_data_lookup'],
    requiresVerification: true,
    verificationFields: ['phone', 'tc', 'vkn'],
    maxAttempts: 3,
    description: 'User asks about DEBTS/PAYMENTS ONLY: bor√ß, borcum, √∂deme, fatura, tahsilat, bakiye, SGK, vergi. NOT about orders or cargo.'
  },

  tracking_info: {
    tools: ['customer_data_lookup'],
    requiresVerification: true,
    verificationFields: ['order_number', 'tracking_number'],
    maxAttempts: 3,
    description: 'User asks about CARGO/SHIPMENT TRACKING ONLY: kargo, g√∂nderi, takip kodu, nerede. NOT about payments or debts.'
  },

  // ============================================
  // NON-VERIFICATION INTENTS
  // ============================================
  stock_check: {
    tools: ['get_product_stock'],
    requiresVerification: false,
    description: 'User asks about product availability, stock, "is X available?"'
  },

  company_info: {
    tools: [],
    requiresVerification: false,
    useKnowledgeBase: true,
    description: 'User asks about company hours, address, services, policies'
  },

  greeting: {
    tools: [],
    requiresVerification: false,
    description: 'User greets: "hello", "hi", "good morning", "merhaba", "selam"'
  },

  complaint: {
    tools: ['create_callback'],
    requiresVerification: false,
    description: 'User complains, reports problem, asks to speak to manager (NOT profanity)'
  },

  profanity: {
    tools: [],
    requiresVerification: false,
    maxCount: 3, // 3 strikes = session terminated
    response: 'polite_warning',
    description: 'User uses profanity, swear words, insults (k√ºf√ºr, hakaret)'
  },

  general_question: {
    tools: [],
    requiresVerification: false,
    useKnowledgeBase: true,
    description: 'General questions about products, services that need KB'
  },

  // ============================================
  // SECURITY INTENTS
  // ============================================
  off_topic: {
    tools: [],
    requiresVerification: false,
    maxCount: 3, // 3 strikes = session terminated
    response: 'polite_redirect',
    description: 'User asks unrelated questions: weather, cooking, jokes, sports'
  }
};

// Session counter storage (in-memory, could be Redis in production)
const sessionCounters = new Map();

// Session timeout: 30 minutes
const SESSION_TIMEOUT = 30 * 60 * 1000;

/**
 * Detect user intent using Gemini
 * @param {string} userMessage - User's message
 * @param {string} language - User's language (TR/EN)
 * @returns {Promise<string>} - Detected intent key
 */
export async function detectIntent(userMessage, language = 'TR') {
  try {
    const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });

    const intentList = Object.keys(INTENT_CONFIG).map(key =>
      `- ${key}: ${INTENT_CONFIG[key].description}`
    ).join('\n');

    const prompt = language === 'TR'
      ? `Kullanƒ±cƒ± ≈üunu dedi: "${userMessage}"

Bu mesajƒ±n niyetini a≈üaƒüƒ±daki listeden se√ß. Mesajƒ±n i√ßeriƒüine g√∂re EN UYGUN intent'i se√ß:

${intentList}

Yanƒ±t olarak SADECE intent adƒ±nƒ± yaz. Hi√ßbir a√ßƒ±klama yapma, sadece intent adƒ±.`
      : `User said: "${userMessage}"

Choose the intent from this list that BEST MATCHES the message content:

${intentList}

Reply with ONLY the intent name. No explanation, just the intent name.`;

    const result = await model.generateContent(prompt);
    const detectedIntent = result.response.text().trim().toLowerCase();

    // Validate intent exists
    if (!INTENT_CONFIG[detectedIntent]) {
      console.warn('‚ö†Ô∏è Unknown intent detected:', detectedIntent);
      return 'general_question'; // fallback
    }

    console.log('üéØ Intent detected:', detectedIntent);
    return detectedIntent;

  } catch (error) {
    console.error('‚ùå Intent detection error:', error);
    return 'general_question'; // fallback on error
  }
}

/**
 * Get or create session counter
 * @param {string} sessionId - Session ID (phone number or chat session)
 * @returns {Object} - Session counter object
 */
function getSessionCounter(sessionId) {
  // Clean up old sessions
  cleanupExpiredSessions();

  if (!sessionCounters.has(sessionId)) {
    sessionCounters.set(sessionId, {
      offTopicCount: 0,
      verificationAttempts: {},
      lastIntent: null,
      timestamp: Date.now()
    });
  }

  // Update timestamp
  const counter = sessionCounters.get(sessionId);
  counter.timestamp = Date.now();

  return counter;
}

/**
 * Cleanup expired sessions (older than 30 minutes)
 */
function cleanupExpiredSessions() {
  const now = Date.now();
  for (const [sessionId, counter] of sessionCounters.entries()) {
    if (now - counter.timestamp > SESSION_TIMEOUT) {
      sessionCounters.delete(sessionId);
      console.log('üßπ Cleaned up expired session:', sessionId);
    }
  }
}

/**
 * Increment off-topic counter
 * @param {string} sessionId - Session ID
 * @returns {Object} - { shouldTerminate: boolean, count: number }
 */
export function incrementOffTopicCounter(sessionId) {
  const counter = getSessionCounter(sessionId);
  counter.offTopicCount += 1;

  console.log(`üìä Off-topic count for ${sessionId}: ${counter.offTopicCount}/3`);

  return {
    shouldTerminate: counter.offTopicCount >= 3,
    count: counter.offTopicCount
  };
}

/**
 * Increment verification attempt counter
 * @param {string} sessionId - Session ID
 * @param {string} intent - Intent type (e.g., 'order_status')
 * @returns {Object} - { shouldTerminate: boolean, count: number }
 */
export function incrementVerificationAttempt(sessionId, intent) {
  const counter = getSessionCounter(sessionId);

  if (!counter.verificationAttempts[intent]) {
    counter.verificationAttempts[intent] = 0;
  }

  counter.verificationAttempts[intent] += 1;

  const maxAttempts = INTENT_CONFIG[intent]?.maxAttempts || 3;
  const currentAttempts = counter.verificationAttempts[intent];

  console.log(`üîí Verification attempts for ${intent}: ${currentAttempts}/${maxAttempts}`);

  return {
    shouldTerminate: currentAttempts >= maxAttempts,
    count: currentAttempts
  };
}

/**
 * Reset session counters
 * @param {string} sessionId - Session ID
 */
export function resetSessionCounters(sessionId) {
  sessionCounters.delete(sessionId);
  console.log('üîÑ Session counters reset:', sessionId);
}

/**
 * Get tools for a specific intent
 * @param {string} intent - Intent key
 * @returns {Array} - List of tool names
 */
export function getToolsForIntent(intent) {
  return INTENT_CONFIG[intent]?.tools || [];
}

/**
 * Check if intent requires verification
 * @param {string} intent - Intent key
 * @returns {boolean}
 */
export function requiresVerification(intent) {
  return INTENT_CONFIG[intent]?.requiresVerification || false;
}

/**
 * Get verification fields for intent
 * @param {string} intent - Intent key
 * @returns {Array} - List of verification field names
 */
export function getVerificationFields(intent) {
  return INTENT_CONFIG[intent]?.verificationFields || [];
}

/**
 * Main intent routing function
 * @param {string} userMessage - User's message
 * @param {string} sessionId - Session ID (phone or chat session)
 * @param {string} language - Language code (TR/EN)
 * @param {Object} businessInfo - Optional business info for personalization
 * @returns {Promise<Object>} - Routing result with intent, tools, and actions
 */
export async function routeIntent(userMessage, sessionId, language = 'TR', businessInfo = {}) {
  try {
    // PRIORITY CHECK: Is user responding to a verification request?
    const pendingVerification = verificationCache.get(sessionId);

    if (pendingVerification) {
      console.log('üîê Pending verification detected - treating message as verification response');

      // Determine which field was requested based on cache
      let requestedField = pendingVerification.requestedField || 'customer_name';
      console.log(`üîç Requested field from cache: ${requestedField}`);

      // Smart detection: If requested VKN but user might have given TC or phone
      if (requestedField === 'vkn') {
        const detectedType = detectNumberType(userMessage);
        console.log(`üîç Auto-detected number type: ${detectedType}`);
        if (detectedType === 'tc' || detectedType === 'phone') {
          requestedField = detectedType;
          console.log(`‚úÖ Corrected field type from 'vkn' to '${requestedField}'`);
        }
      }

      // User is providing verification info (name, phone, VKN, TC, etc.)
      // Route to customer_data_lookup with the user's response in the appropriate field
      return {
        intent: 'verification_response',
        tools: ['customer_data_lookup'],
        shouldTerminate: false,
        // Pass user message in the dynamically determined field
        verificationData: {
          [requestedField]: userMessage.trim()
        }
      };
    }

    // 1. Detect intent
    const intent = await detectIntent(userMessage, language);

    // 2. Handle profanity (k√ºf√ºr) - 3 strikes
    if (intent === 'profanity') {
      const counter = getSessionCounter(sessionId);

      if (!counter.profanityCount) {
        counter.profanityCount = 0;
      }

      counter.profanityCount += 1;
      const profanityCount = counter.profanityCount;

      console.log(`üö´ Profanity count for ${sessionId}: ${profanityCount}/3`);

      if (profanityCount >= 3) {
        // 3rd strike - terminate
        return {
          intent,
          tools: [],
          shouldTerminate: true,
          response: language === 'TR'
            ? 'G√ºvenlik nedeniyle oturumunuz sonlandƒ±rƒ±ldƒ±.'
            : 'Your session has been terminated for security reasons.'
        };
      }

      // 1st and 2nd strike - polite warning
      return {
        intent,
        tools: [],
        shouldTerminate: false,
        response: language === 'TR'
          ? 'L√ºtfen saygƒ±lƒ± bir dil kullanƒ±n. Size nasƒ±l yardƒ±mcƒ± olabilirim?'
          : 'Please use respectful language. How can I help you?'
      };
    }

    // 3. Handle off-topic
    if (intent === 'off_topic') {
      const { shouldTerminate, count } = incrementOffTopicCounter(sessionId);

      const businessName = businessInfo.name || '≈üirketimiz';

      // If session should terminate, use hardcoded message
      if (shouldTerminate) {
        return {
          intent,
          tools: [],
          shouldTerminate: true,
          response: language === 'TR'
            ? 'G√ºvenlik nedeniyle oturumunuz sonlandƒ±rƒ±ldƒ±.'
            : 'Your session has been terminated for security reasons.'
        };
      }

      // Generate natural AI response for off-topic (1st and 2nd strike)
      try {
        const model = genAI.getGenerativeModel({
          model: 'gemini-2.5-flash',
          generationConfig: {
            temperature: 0.7,
            maxOutputTokens: 500,  // Plenty of tokens for a natural response
            stopSequences: ['\n\n', '---', '*'],  // Stop at formatting attempts
            // CRITICAL: Disable thinking mode - this is the real fix!
            thinkingConfig: {
              thinkingBudget: 0
            }
          },
          safetySettings: [
            { category: 'HARM_CATEGORY_HARASSMENT', threshold: 'BLOCK_NONE' },
            { category: 'HARM_CATEGORY_HATE_SPEECH', threshold: 'BLOCK_NONE' },
            { category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT', threshold: 'BLOCK_NONE' },
            { category: 'HARM_CATEGORY_DANGEROUS_CONTENT', threshold: 'BLOCK_NONE' }
          ]
        });

        // Simple, direct prompt - avoid any formatting instructions
        const aiPrompt = language === 'TR'
          ? `Kullanƒ±cƒ± ≈üunu sordu: "${userMessage}"

Bu soruya kibarca hayƒ±r de ve ${businessName} i√ßin sadece sipari≈ü takibi ve stok kontrol√º yapabildiƒüini s√∂yle. Sadece yanƒ±tƒ± yaz, ba≈üka bir ≈üey ekleme.`
          : `User asked: "${userMessage}"

Politely decline and say you can only help with order tracking and stock check for ${businessName}. Just write the response, nothing else.`;

        console.log('üìù Off-topic prompt sent to Gemini (length:', aiPrompt.length, 'chars):', aiPrompt);

        const result = await model.generateContent(aiPrompt);
        const response = result.response;

        console.log('üîç Full Gemini result object:', JSON.stringify(result, null, 2));
        console.log('üîç Gemini response candidates:', response.candidates);
        console.log('üîç Gemini response object:', {
          text: response.text ? response.text() : 'NO TEXT',
          candidates: response.candidates?.length,
          finishReason: response.candidates?.[0]?.finishReason,
          promptFeedback: response.promptFeedback
        });

        const aiResponse = response.text().trim();

        console.log('‚úÖ Off-topic AI response generated (length:', aiResponse.length, '):', aiResponse);

        return {
          intent,
          tools: [],
          shouldTerminate: false,
          response: aiResponse
        };

      } catch (error) {
        console.error('‚ùå AI response generation failed, using fallback:', error);

        // Fallback to simple message if AI fails
        return {
          intent,
          tools: [],
          shouldTerminate: false,
          response: language === 'TR'
            ? `√úzg√ºn√ºm, sadece ${businessName} ile ilgili sorularƒ±nƒ±zƒ± yanƒ±tlayabilirim. Size nasƒ±l yardƒ±mcƒ± olabilirim?`
            : `Sorry, I can only answer questions about ${businessName}. How can I help you?`
        };
      }
    }

    // 3. Get tools for intent
    const tools = getToolsForIntent(intent);
    const config = INTENT_CONFIG[intent];

    // 4. Return routing result
    return {
      intent,
      tools,
      requiresVerification: config.requiresVerification,
      verificationFields: config.verificationFields,
      useKnowledgeBase: config.useKnowledgeBase,
      shouldTerminate: false
    };

  } catch (error) {
    console.error('‚ùå Intent routing error:', error);

    // Fallback to general question
    return {
      intent: 'general_question',
      tools: [],
      requiresVerification: false,
      shouldTerminate: false
    };
  }
}

/**
 * Handle verification failure
 * @param {string} sessionId - Session ID
 * @param {string} intent - Intent that failed verification
 * @param {string} language - Language code
 * @returns {Object} - { shouldTerminate: boolean, response: string }
 */
export function handleVerificationFailure(sessionId, intent, language = 'TR') {
  const { shouldTerminate, count } = incrementVerificationAttempt(sessionId, intent);

  const maxAttempts = INTENT_CONFIG[intent]?.maxAttempts || 3;

  return {
    shouldTerminate,
    response: language === 'TR'
      ? shouldTerminate
        ? 'G√ºvenlik nedeniyle oturumunuz sonlandƒ±rƒ±ldƒ±. L√ºtfen m√º≈üteri hizmetlerini arayƒ±n.'
        : `Kayƒ±t bulunamadƒ±. L√ºtfen bilgilerinizi kontrol edin. (${count}/${maxAttempts})`
      : shouldTerminate
        ? 'Your session has been terminated for security reasons. Please contact customer service.'
        : `Record not found. Please check your information. (${count}/${maxAttempts})`
  };
}

export default {
  detectIntent,
  routeIntent,
  getToolsForIntent,
  requiresVerification,
  getVerificationFields,
  incrementOffTopicCounter,
  incrementVerificationAttempt,
  resetSessionCounters,
  handleVerificationFailure
};
