/**
 * Customer Data Lookup Handler V2
 * Uses centralized VerificationService and Tool Result Contract
 *
 * Flow:
 * 1. Find record (anchor)
 * 2. Check verification status
 * 3. Return minimal or full data based on verification
 *
 * SECURITY (P0 Fix): Order number normalization to prevent lookup failures
 */

import prisma from '../../prismaClient.js';
import { normalizePhone, phoneSearchVariants } from '../../utils/text.js';
import {
  isLikelyValidOrderNumber,
  normalizeOrderLookupInput,
  normalizeOrderNumber
} from '../../utils/order-number.js';
import { isValidTckn, isValidVkn } from '../../utils/pii-validators/tr.js';

function looksLikePhoneIdentifier(value) {
  if (!value) return false;
  const raw = String(value).trim();
  if (!raw) return false;

  // If there are letters, treat it as an order/reference code, not phone.
  if (/[a-zA-Z\u00C0-\u024F]/.test(raw)) return false;

  const digits = raw.replace(/\D/g, '');
  return digits.length === 10 || digits.length === 11;
}

async function findRecordByPhone({ businessId, phone, queryType }) {
  const variants = phoneSearchVariants(phone);
  const normalizedPhone = normalizePhone(phone);
  const normalizedQueryType = String(queryType || '').toLowerCase();

  // First try CustomerData table
  let record = await prisma.customerData.findFirst({
    where: {
      businessId,
      OR: variants.map(v => ({ phone: v }))
    }
  });
  let sourceTable = 'CustomerData';

  // If CustomerData found AND query is order-related, fetch latest CrmOrder.
  if (record && (normalizedQueryType === 'siparis' || normalizedQueryType === 'order')) {
    const relatedOrder = await prisma.crmOrder.findFirst({
      where: {
        businessId,
        OR: variants.map(v => ({ customerPhone: v }))
      },
      orderBy: { createdAt: 'desc' } // Most recent order
    });

    if (relatedOrder) {
      record = relatedOrder;
      sourceTable = 'CrmOrder';
    }
  }

  // If not found in CustomerData, try CrmOrder table
  if (!record) {
    const crmOrder = await prisma.crmOrder.findFirst({
      where: {
        businessId,
        OR: variants.map(v => ({ customerPhone: v }))
      }
    });

    if (crmOrder) {
      record = crmOrder;
      sourceTable = 'CrmOrder';
    }
  }

  return {
    record,
    sourceTable,
    normalizedPhone,
    variantsCount: variants.length
  };
}
import {
  requiresVerification,
  createAnchor,
  checkVerification,
  getMinimalResult,
  getFullResult,
  verifyAgainstAnchor
} from '../../services/verification-service.js';
import {
  ok,
  notFound,
  validationError,
  verificationRequired,
  systemError,
  ToolOutcome,
  GENERIC_ERROR_MESSAGES
} from '../toolResult.js';
import { OutcomeEventType } from '../../security/outcomePolicy.js';

function toStateAnchor(anchor) {
  if (!anchor) return null;
  return {
    id: anchor.id,
    customerId: anchor.customerId || null,
    type: anchor.anchorType,
    value: anchor.anchorValue,
    name: anchor.name,
    phone: anchor.phone,
    email: anchor.email,
    sourceTable: anchor.sourceTable
  };
}

function isSameVerificationScope(previousAnchor, nextAnchor) {
  if (!previousAnchor || !nextAnchor) return false;

  if (
    previousAnchor.id &&
    nextAnchor.id &&
    String(previousAnchor.id) === String(nextAnchor.id)
  ) {
    return true;
  }

  if (
    previousAnchor.customerId &&
    nextAnchor.customerId &&
    String(previousAnchor.customerId) === String(nextAnchor.customerId)
  ) {
    return true;
  }

  return false;
}

const ORDER_CUSTOM_FIELD_NAMES = Object.freeze([
  'Sipari≈ü No',
  'Siparis No',
  'Sƒ∞PARƒ∞≈û NO',
  'Sipari≈ü Numarasƒ±',
  'order_number',
  'orderNumber',
  'Order Number',
  'Order No'
]);

function buildOrderLookupCandidates(orderNumber) {
  const normalizedLookup = normalizeOrderLookupInput(orderNumber);
  const compactNormalized = normalizeOrderNumber(orderNumber);
  const compactLookup = normalizedLookup.replace(/\s+/g, '');

  return {
    normalizedLookup,
    compactNormalized,
    exactCandidates: Array.from(new Set([
      normalizedLookup,
      compactLookup,
      compactNormalized
    ].filter(Boolean)))
  };
}

function normalizedOrderMatch(value, normalizedOrder) {
  if (!value || !normalizedOrder) return false;
  return normalizeOrderNumber(String(value)) === normalizedOrder;
}

function buildOrderAmbiguityResponse(language = 'TR') {
  return {
    outcome: ToolOutcome.NEED_MORE_INFO,
    success: true,
    data: null,
    message: language === 'TR'
      ? 'Bu sipari≈ü numarasƒ± birden fazla kayƒ±tla e≈üle≈üti. L√ºtfen sipari≈ü numarasƒ±nƒ± tek bir formatla tekrar payla≈üƒ±r mƒ±sƒ±n?'
      : 'This order number matches multiple records. Please share the order number again in a single exact format.',
    field: 'order_number',
    ambiguity: true
  };
}

/**
 * Execute customer data lookup
 */
export async function execute(args, business, context = {}) {
  try {
    const { query_type, phone, order_number, customer_name, vkn, tc, verification_input } = args;
    const sessionId = context.sessionId || context.conversationId;
    const language = business.language || 'TR';
    const state = context.state || {};
    const verificationState = state.verification?.status || state.verificationStatus || 'none';
    const isSessionVerified = verificationState === 'verified';

    // P0-C SECURITY FIX: verification_input ONLY accepted when state is pending/failed
    // Prevents LLM single-shot bypass (sending all params in one call)
    const isVerificationPending = verificationState === 'pending' || verificationState === 'failed';
    const effectiveVerificationInput = isVerificationPending
      ? (verification_input || customer_name)
      : null; // Ignore verification_input when not in verification flow

    const normalizedQueryType = String(query_type || '').toLowerCase();
    const isOrderQuery = normalizedQueryType === 'siparis' || normalizedQueryType === 'order';
    const orderLookup = order_number ? buildOrderLookupCandidates(order_number) : null;

    // Minimal validation only: reject empty/too-short values.
    // Do not apply format/prefix regex gates before DB lookup.
    if (isOrderQuery && order_number !== undefined && order_number !== null && !isLikelyValidOrderNumber(order_number)) {
      return validationError(
        language === 'TR'
          ? 'Sipari≈ü numarasƒ± √ßok kƒ±sa g√∂r√ºn√ºyor. En az 3 karakter olacak ≈üekilde tekrar payla≈üƒ±r mƒ±sƒ±n?'
          : 'The order number looks too short. Please share it again with at least 3 characters.',
        'order_number'
      );
    }

    // SECURITY: Don't log PII (phone, vkn, tc, names)
    console.log('üîç [CustomerDataLookup-V2] Query:', {
      query_type,
      has_phone: !!phone,
      has_order: !!order_number,
      has_name: !!customer_name,
      has_vkn: !!vkn,
      has_tc: !!tc,
      businessId: business.id,
      sessionId,
      verificationStatus: verificationState
    });

    // ============================================================================
    // P0: VERIFICATION HANDLER - Process pending verification
    // ============================================================================

    console.log('üîê [Debug] Verification check:', {
      hasState: !!state,
      hasVerification: !!state.verification,
      status: verificationState,
      hasAnchor: !!state.verification?.anchor,
      hasVerificationInput: !!effectiveVerificationInput,
      verificationInput: effectiveVerificationInput
    });

    // P0-UX FIX: Process verification with ANY verification input (name OR phone_last4)
    // RECOVERY: Also handle 'failed' status ‚Äî if user provides correct input, forgive past mistakes
    // Note: isVerificationPending already computed above (P0-C fix)
    if (isVerificationPending && state.verification?.anchor && effectiveVerificationInput) {
      console.log('üîê [Verification] Processing verification (status:', state.verification.status, ')');
      console.log('üîê [Verification] Input:', effectiveVerificationInput, '| Anchor phone:', state.verification.anchor.phone);

      const anchor = state.verification.anchor;
      const verifyResult = checkVerification(anchor, effectiveVerificationInput, query_type, language);

      if (verifyResult.action === 'PROCEED') {
        // Fetch the full record using anchor ID from the CORRECT table
        const table = anchor.sourceTable || 'CustomerData';
        console.log('üîç [Verification] Fetching verified record from:', table, 'id:', anchor.id);

        let verifiedRecord;
        if (table === 'CrmOrder') {
          verifiedRecord = await prisma.crmOrder.findUnique({ where: { id: anchor.id } });
        } else {
          verifiedRecord = await prisma.customerData.findUnique({ where: { id: anchor.id } });
        }

        if (verifiedRecord) {
          const fullResult = getFullResult(verifiedRecord, query_type, language);
          return {
            ...fullResult,
            stateEvents: [
              {
                type: OutcomeEventType.VERIFICATION_PASSED,
                anchor: toStateAnchor(anchor),
                attempts: 0
              }
            ]
          };
        }

        return systemError(
          language === 'TR'
            ? 'Kayƒ±t bulunamadƒ±.'
            : 'Record not found.'
        );
      }

      // Tool remains pure: compute attempt outcome, orchestrator mutates state.
      const nextAttempts = (state.verification?.attempts || 0) + 1;
      console.log(`‚ùå [Verification] Failed - attempt ${nextAttempts}`);

      // Loop breaker: After 2 failed attempts, return validation outcome directly.
      if (nextAttempts >= 2) {
        console.log('üîÑ [Verification] Max attempts reached - returning validation error');
        return {
          outcome: ToolOutcome.VALIDATION_ERROR,
          success: true,
          message: language === 'TR'
            ? 'Bilgiler doƒürulanamadƒ±. Sipari≈ü numaranƒ±zƒ± kontrol edebilir misiniz? Farklƒ± bir sipari≈ü sorgulamak isterseniz sipari≈ü numarasƒ±nƒ± s√∂yleyin.'
            : 'Could not verify the information. Can you check your order number? If you want to query a different order, please provide the order number.',
          stateEvents: [
            {
              type: OutcomeEventType.VERIFICATION_FAILED,
              attempts: nextAttempts
            }
          ]
        };
      }

      // First failure: generic not_found response (security) + verification.failed event
      return {
        ...notFound(GENERIC_ERROR_MESSAGES[language] || GENERIC_ERROR_MESSAGES.TR),
        stateEvents: [
          {
            type: OutcomeEventType.VERIFICATION_FAILED,
            attempts: nextAttempts
          }
        ]
      };
    }

    // ============================================================================
    // STEP 1: FIND RECORD (ANCHOR)
    // ============================================================================

    let record = null;
    let anchorType = null;
    let anchorValue = null;
    let sourceTable = 'CustomerData'; // Track which DB table the record came from

    // Strategy 1: Order number
    if (order_number) {
      const {
        normalizedLookup,
        compactNormalized,
        exactCandidates
      } = orderLookup;

      console.log('üîç [Lookup] Searching by order_number:', {
        original: order_number,
        normalizedLookup,
        compactNormalized,
        exactCandidates
      });

      const crmOrderCandidates = await prisma.crmOrder.findMany({
        where: {
          businessId: business.id,
          orderNumber: { in: exactCandidates }
        }
      });

      const normalizedCrmOrders = crmOrderCandidates.filter(
        (candidate) => normalizedOrderMatch(candidate.orderNumber, compactNormalized)
      );

      if (normalizedCrmOrders.length > 1) {
        console.warn('‚ö†Ô∏è [Lookup] Ambiguous CrmOrder matches for normalized order number:', {
          businessId: business.id,
          order_number: normalizedLookup,
          normalized: compactNormalized,
          matchCount: normalizedCrmOrders.length
        });
        return buildOrderAmbiguityResponse(language);
      }

      const crmOrder = normalizedCrmOrders[0];

      if (crmOrder) {
        console.log('‚úÖ [Lookup] Found CRM order:', crmOrder.orderNumber);
        record = crmOrder;
        anchorType = 'order';
        anchorValue = crmOrder.orderNumber;
        sourceTable = 'CrmOrder';
      } else {
        console.log('üîç [Lookup] Not in CrmOrder, searching CustomerData with DB filters...');

        const customerOrderNoCandidates = await prisma.customerData.findMany({
          where: {
            businessId: business.id,
            orderNo: { in: exactCandidates }
          }
        });

        const normalizedCustomerOrderNoMatches = customerOrderNoCandidates.filter(
          (candidate) => normalizedOrderMatch(candidate.orderNo, compactNormalized)
        );

        const customFieldWhereClauses = [];
        for (const fieldName of ORDER_CUSTOM_FIELD_NAMES) {
          for (const candidate of exactCandidates) {
            customFieldWhereClauses.push({
              customFields: {
                path: [fieldName],
                equals: candidate
              }
            });
          }
        }

        let normalizedCustomerCustomFieldMatches = [];
        if (customFieldWhereClauses.length > 0) {
          const customerCustomFieldCandidates = await prisma.customerData.findMany({
            where: {
              businessId: business.id,
              OR: customFieldWhereClauses
            }
          });

          normalizedCustomerCustomFieldMatches = customerCustomFieldCandidates.filter((candidate) => {
            if (!candidate.customFields || typeof candidate.customFields !== 'object') {
              return false;
            }

            return ORDER_CUSTOM_FIELD_NAMES.some((fieldName) => {
              const fieldValue = candidate.customFields[fieldName];
              return normalizedOrderMatch(fieldValue, compactNormalized);
            });
          });
        }

        const normalizedCustomerMatchesMap = new Map();
        for (const match of normalizedCustomerOrderNoMatches) {
          normalizedCustomerMatchesMap.set(match.id, match);
        }
        for (const match of normalizedCustomerCustomFieldMatches) {
          normalizedCustomerMatchesMap.set(match.id, match);
        }
        const normalizedCustomerMatches = Array.from(normalizedCustomerMatchesMap.values());

        if (normalizedCustomerMatches.length > 1) {
          console.warn('‚ö†Ô∏è [Lookup] Ambiguous CustomerData matches for normalized order number:', {
            businessId: business.id,
            order_number: normalizedLookup,
            normalized: compactNormalized,
            matchCount: normalizedCustomerMatches.length
          });
          return buildOrderAmbiguityResponse(language);
        }

        if (normalizedCustomerMatches.length === 1) {
          const matchedCustomer = normalizedCustomerMatches[0];
          console.log('‚úÖ [Lookup] Found in CustomerData by exact DB-level match');
          record = matchedCustomer;
          anchorType = 'order';
          anchorValue = matchedCustomer.orderNo || normalizedLookup;
        }

        if (!record) {
          if (looksLikePhoneIdentifier(order_number)) {
            // Deterministic recovery: if order-like lookup fails but identifier is numeric 10-11,
            // retry as phone to avoid false NOT_FOUND due LLM arg mismatch.
            console.log('üîÅ [Lookup] Order not found, retrying same identifier as phone');
            const phoneLookup = await findRecordByPhone({
              businessId: business.id,
              phone: order_number,
              queryType: query_type
            });

            if (phoneLookup.record) {
              console.log('‚úÖ [Lookup] Recovered via phone fallback');
              record = phoneLookup.record;
              sourceTable = phoneLookup.sourceTable;
              anchorType = 'phone';
              anchorValue = phoneLookup.normalizedPhone.replace(/^\+/, '');
            }
          }

          if (!record) {
            // P0-1 FIX: Use generic message to prevent enumeration attacks
            // SECURITY: Do NOT reveal that this specific order number doesn't exist
            console.log('üì≠ [Lookup] Order not found in both CrmOrder and CustomerData');
            return notFound(GENERIC_ERROR_MESSAGES[language] || GENERIC_ERROR_MESSAGES.TR);
          }
        }
      }
    }

    // Strategy 2: VKN/TC
    else if (vkn || tc) {
      // Validate TC/VKN checksum before DB query ‚Äî reject invalid early
      if (tc && !isValidTckn(tc)) {
        console.log('‚ùå [Lookup] Invalid TCKN checksum:', { tc: '***' });
        return validationError(
          language === 'TR'
            ? 'Ge√ßersiz TC Kimlik numarasƒ±. L√ºtfen 11 haneli TC Kimlik numaranƒ±zƒ± kontrol edip tekrar payla≈üƒ±r mƒ±sƒ±nƒ±z?'
            : 'Invalid Turkish ID number. Please check your 11-digit ID number and try again.',
          'tc'
        );
      }
      if (vkn && !isValidVkn(vkn)) {
        console.log('‚ùå [Lookup] Invalid VKN checksum:', { vkn: '***' });
        return validationError(
          language === 'TR'
            ? 'Ge√ßersiz VKN (Vergi Kimlik Numarasƒ±). L√ºtfen 10 haneli VKN\'nizi kontrol edip tekrar payla≈üƒ±r mƒ±sƒ±nƒ±z?'
            : 'Invalid tax ID number. Please check your 10-digit tax ID and try again.',
          'vkn'
        );
      }

      console.log('üîç [Lookup] Searching by VKN/TC');

      const whereClause = { businessId: business.id };
      if (vkn) whereClause.vkn = vkn;
      else if (tc) whereClause.tcNo = tc;

      record = await prisma.customerData.findFirst({ where: whereClause });

      if (record) {
        anchorType = vkn ? 'vkn' : 'tc';
        anchorValue = vkn || tc;
      } else {
        // P0-1 FIX: Use generic message to prevent enumeration attacks
        return notFound(GENERIC_ERROR_MESSAGES[language] || GENERIC_ERROR_MESSAGES.TR);
      }
    }

    // Strategy 3: Phone
    // SECURITY NOTE: Phone lookup is allowed, but will ALWAYS require name verification
    // before returning any PII (enforced by checkVerification below)
    else if (phone) {
      const phoneLookup = await findRecordByPhone({
        businessId: business.id,
        phone,
        queryType: query_type
      });

      console.log('üîç [Lookup] Searching by phone:', {
        original: phone,
        normalized: phoneLookup.normalizedPhone,
        variants: phoneLookup.variantsCount
      });

      if (phoneLookup.record) {
        record = phoneLookup.record;
        sourceTable = phoneLookup.sourceTable;
        anchorType = 'phone';
        anchorValue = phoneLookup.normalizedPhone.replace(/^\+/, '');
      }
    }

    // No record found
    if (!record) {
      // P0-1 FIX: Use generic message to prevent enumeration attacks
      console.log('üì≠ [Lookup] No record found');
      return notFound(GENERIC_ERROR_MESSAGES[language] || GENERIC_ERROR_MESSAGES.TR);
    }

    // ============================================================================
    // STEP 2: CHECK VERIFICATION
    // ============================================================================

    const anchor = createAnchor(record, anchorType, anchorValue, sourceTable);

    // Resolve customerId for CrmOrder records (CrmOrder has no FK to CustomerData).
    // Look up CustomerData by phone to establish the customer identity chain.
    // If no match or multiple matches ‚Üí customerId stays null ‚Üí autoverify blocked (fail-closed).
    if (sourceTable === 'CrmOrder' && !anchor.customerId && anchor.phone) {
      try {
        // Use phoneSearchVariants for international-aware matching
        const resolveVariants = phoneSearchVariants(anchor.phone);

        const customerMatches = await prisma.customerData.findMany({
          where: {
            businessId: business.id,
            OR: resolveVariants.map(p => ({ phone: p }))
          },
          select: { id: true },
          take: 2 // We only need to know if it's exactly 1
        });

        if (customerMatches.length === 1) {
          anchor.customerId = customerMatches[0].id;
          console.log('üîó [Anchor] Resolved CrmOrder ‚Üí CustomerData customerId:', anchor.customerId);
        } else {
          console.log('üîó [Anchor] CrmOrder customerId unresolvable (matches:', customerMatches.length, ')');
        }
      } catch (resolveErr) {
        console.error('‚ö†Ô∏è [Anchor] customerId resolution error (fail-closed):', resolveErr.message);
        // anchor.customerId stays null ‚Üí autoverify will not apply
      }
    }

    console.log('üîê [Anchor] Created:', { type: anchor.anchorType, value: anchor.anchorValue, name: anchor.name, customerId: anchor.customerId, sourceTable: anchor.sourceTable });

    // Attach identity context for central autoverify decision in 06_toolLoop.
    // Tool handler does NOT make the autoverify decision ‚Äî it only provides context.
    const _identityContext = {
      channel: context.channel || null,
      channelUserId: context.channelUserId || null,
      fromEmail: context.fromEmail || null,
      businessId: business.id,
      anchorId: anchor.id,
      anchorCustomerId: anchor.customerId,  // P0: customerId chain for autoverify
      anchorSourceTable: anchor.sourceTable,
      queryType: query_type
    };

    const previousVerificationAnchor = state.verification?.anchor || null;
    const sameVerificationScope = isSameVerificationScope(previousVerificationAnchor, anchor);
    const hasPreviousVerificationAnchor = Boolean(previousVerificationAnchor?.id);
    console.log('üîê [Debug] Identity switch check:', {
      hasStateAnchor: hasPreviousVerificationAnchor,
      stateAnchorId: previousVerificationAnchor?.id,
      stateAnchorCustomerId: previousVerificationAnchor?.customerId || null,
      newAnchorId: anchor.id,
      newAnchorCustomerId: anchor.customerId || null,
      sameVerificationScope
    });
    const identitySwitch = hasPreviousVerificationAnchor && !sameVerificationScope;

    if (identitySwitch) {
      console.log('üö® [SECURITY] Identity switch detected!', {
        previousAnchor: previousVerificationAnchor?.id,
        previousCustomerId: previousVerificationAnchor?.customerId || null,
        newAnchor: anchor.id,
        newCustomerId: anchor.customerId || null
      });

      // Force new verification by treating as if no verification data provided
      // ToolLoop will handle state reset when VERIFICATION_REQUIRED is returned
      console.log('üîê [SECURITY] Forcing new verification for identity switch');

      // Return VERIFICATION_REQUIRED immediately - ignore any provided customer_name
      return {
        ...verificationRequired(
          language === 'TR'
            ? 'Farklƒ± bir m√º≈üteri kaydƒ± tespit edildi. G√ºvenlik doƒürulamasƒ± i√ßin isminizi ve soyadƒ±nƒ±zƒ± s√∂yler misiniz?'
            : 'Different customer record detected. For security verification, could you please provide your full name?',
          {
            askFor: 'name',
            anchor: toStateAnchor(anchor)
          }
        ),
        stateEvents: [
          {
            type: OutcomeEventType.VERIFICATION_REQUIRED,
            askFor: 'name',
            anchor: toStateAnchor(anchor)
          }
        ]
      };
    }

    // SESSION-LEVEL VERIFIED BYPASS (scoped):
    // Only bypass re-verification when current anchor/customer scope matches
    // the previously verified anchor in session state.
    if (isSessionVerified && sameVerificationScope) {
      console.log('‚úÖ [Verification] Session already verified for same scope ‚Äî bypassing checkVerification');
      const fullResult = getFullResult(record, query_type, language);
      return {
        ...ok(fullResult.data, fullResult.message),
        _identityContext,
        stateEvents: [
          {
            type: OutcomeEventType.VERIFICATION_PASSED,
            anchor: toStateAnchor(anchor),
            attempts: 0
          }
        ]
      };
    }

    if (isSessionVerified && !sameVerificationScope) {
      console.log('üîê [Verification] Verified session scope mismatch ‚Äî fresh verification required');
    }

    // P0 SECURITY: Enforce two-step verification AND detect mismatches
    // Strategy:
    // 1. If customer_name provided AND not in pending state ‚Üí check for mismatch
    // 2. If mismatch detected ‚Üí return explicit error
    // 3. If match detected ‚Üí still require verification (prevent single-shot bypass)
    //
    // PENDING STATE EXCEPTION:
    // When state.verification.status === 'pending', allow verification_input
    // (which can be name OR full phone number) to pass through for verification.
    // This enables email pipeline (stateless, synthesizes pending) to complete
    // verification in a single pass without multi-turn back-and-forth.
    // verifyAgainstAnchor() accepts: name, phone_last4, or full phone (10+ digits).
    let verificationInput = customer_name;
    // Reuse isVerificationPending from P0-C fix above
    if (isVerificationPending) {
      // Pending state: accept any verification input (name or phone)
      verificationInput = customer_name || verification_input;
    }
    if (customer_name && !isVerificationPending) {
      console.log('üîê [SECURITY] customer_name provided but not in pending verification flow');
      console.log('üîê [SECURITY] Checking for mismatch...');

      // Check if provided name matches anchor
      const matchResult = verifyAgainstAnchor(anchor, customer_name);

      if (!matchResult.matches) {
        // P0-1 FIX: Use SAME generic message as NOT_FOUND to prevent enumeration
        // SECURITY: "ƒ∞sim e≈üle≈ümiyor" reveals that record EXISTS - information leak!
        console.log('üîê [SECURITY] Mismatch detected - returning generic error (same as NOT_FOUND)');
        return {
          ...notFound(GENERIC_ERROR_MESSAGES[language] || GENERIC_ERROR_MESSAGES.TR),
          stateEvents: [
            {
              type: OutcomeEventType.VERIFICATION_FAILED,
              attempts: (state.verification?.attempts || 0) + 1
            }
          ]
        };
      }

      // Name matches BUT still require two-step verification (prevent single-shot bypass)
      console.log('üîê [SECURITY] Name matches but enforcing two-step verification');
      verificationInput = null; // Force verification request
    }

    const verificationCheck = checkVerification(anchor, verificationInput, query_type, language);
    console.log('üîê [Verification] Check result:', verificationCheck.action);

    // Handle verification result
    if (verificationCheck.action === 'REQUEST_VERIFICATION') {
      return {
        ...verificationRequired(verificationCheck.message, {
          askFor: verificationCheck.askFor,
          anchor: verificationCheck.anchor
        }),
        _identityContext,  // For central autoverify decision in 06_toolLoop
        stateEvents: [
          {
            type: OutcomeEventType.VERIFICATION_REQUIRED,
            askFor: verificationCheck.askFor,
            anchor: verificationCheck.anchor
          }
        ]
      };
    }

    if (verificationCheck.action === 'VERIFICATION_FAILED') {
      // P0-1 FIX: Use SAME generic message as NOT_FOUND to prevent enumeration
      // SECURITY: Specific verification failure messages reveal record existence
      console.log('üîê [Verification] Check failed - returning generic error');
      return {
        ...notFound(GENERIC_ERROR_MESSAGES[language] || GENERIC_ERROR_MESSAGES.TR),
        stateEvents: [
          {
            type: OutcomeEventType.VERIFICATION_FAILED,
            attempts: (state.verification?.attempts || 0) + 1
          }
        ]
      };
    }

    // ============================================================================
    // STEP 3: RETURN DATA (minimal or full)
    // ============================================================================

    if (verificationCheck.verified) {
      console.log('‚úÖ [Result] Returning full data');
      const result = getFullResult(record, query_type, language);
      return {
        ...ok(result.data, result.message),
        stateEvents: [
          {
            type: OutcomeEventType.VERIFICATION_PASSED,
            anchor: toStateAnchor(anchor),
            attempts: 0
          }
        ]
      };
    } else {
      console.log('‚ö†Ô∏è [Result] Returning minimal data (unverified)');
      const result = getMinimalResult(record, query_type, language);
      return ok(result.data, result.message);
    }

  } catch (error) {
    console.error('‚ùå [CustomerDataLookup-V2] Error:', error);
    return systemError(
      business.language === 'TR'
        ? 'Sistem hatasƒ± olu≈ütu. L√ºtfen daha sonra tekrar deneyin.'
        : 'A system error occurred. Please try again later.',
      error
    );
  }
}

export default { execute };
